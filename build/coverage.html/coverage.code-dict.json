{"/home/travis/build/npmtest/node-npmtest-dav/test.js":"/* istanbul instrument in package npmtest_dav */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-dav/lib.npmtest_dav.js":"/* istanbul instrument in package npmtest_dav */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_dav = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_dav = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-dav/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-dav && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_dav */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_dav\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_dav.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_dav.rollup.js'] =\n            local.assetsDict['/assets.npmtest_dav.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_dav.__dirname +\n                    '/lib.npmtest_dav.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/dav.js":"/**\n * Polyfill from developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/find\n */\nif (!Array.prototype.find) {\n  Array.prototype.find = function(predicate) {\n    if (this == null) {\n      throw new TypeError('Array.prototype.find called on null or undefined');\n    }\n    if (typeof predicate !== 'function') {\n      throw new TypeError('predicate must be a function');\n    }\n    var list = Object(this);\n    var length = list.length >>> 0;\n    var thisArg = arguments[1];\n    var value;\n\n    for (var i = 0; i < length; i++) {\n      value = list[i];\n      if (predicate.call(thisArg, value, i, list)) {\n        return value;\n      }\n    }\n    return undefined;\n  };\n}\n/**\n * Polyfill from developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n */\nif (!Object.assign) {\n  Object.defineProperty(Object, 'assign', {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function(target, firstSource) {\n      'use strict';\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert first argument to object');\n      }\n\n      var to = Object(target);\n      for (var i = 1; i < arguments.length; i++) {\n        var nextSource = arguments[i];\n        if (nextSource === undefined || nextSource === null) {\n          continue;\n        }\n        nextSource = Object(nextSource);\n\n        var keysArray = Object.keys(Object(nextSource));\n        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n          var nextKey = keysArray[nextIndex];\n          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n          if (desc !== undefined && desc.enumerable) {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n      return to;\n    }\n  });\n}\n/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var iteratorSymbol =\n    typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided, then outerFn.prototype instanceof Generator.\n    var generator = Object.create((outerFn || Generator).prototype);\n\n    generator._invoke = makeInvokeMethod(\n      innerFn, self || null,\n      new Context(tryLocsList || [])\n    );\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    genFun.__proto__ = GeneratorFunctionPrototype;\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    return new Promise(function(resolve, reject) {\n      var generator = wrap(innerFn, outerFn, self, tryLocsList);\n      var callNext = step.bind(generator, \"next\");\n      var callThrow = step.bind(generator, \"throw\");\n\n      function step(method, arg) {\n        var record = tryCatch(generator[method], generator, arg);\n        if (record.type === \"throw\") {\n          reject(record.arg);\n          return;\n        }\n\n        var info = record.arg;\n        if (info.done) {\n          resolve(info.value);\n        } else {\n          Promise.resolve(info.value).then(callNext, callThrow);\n        }\n      }\n\n      callNext();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          if (method === \"return\" ||\n              (method === \"throw\" && delegate.iterator[method] === undefined)) {\n            // A return or throw (when the delegate iterator has no throw\n            // method) always terminates the yield* loop.\n            context.delegate = null;\n\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            var returnMethod = delegate.iterator[\"return\"];\n            if (returnMethod) {\n              var record = tryCatch(returnMethod, delegate.iterator, arg);\n              if (record.type === \"throw\") {\n                // If the return method threw an exception, let that\n                // exception prevail over the original return or throw.\n                method = \"throw\";\n                arg = record.arg;\n                continue;\n              }\n            }\n\n            if (method === \"return\") {\n              // Continue with the outer return, now that the delegate\n              // iterator has been terminated.\n              continue;\n            }\n          }\n\n          var record = tryCatch(\n            delegate.iterator[method],\n            delegate.iterator,\n            arg\n          );\n\n          if (record.type === \"throw\") {\n            context.delegate = null;\n\n            // Like returning generator.throw(uncaught), but without the\n            // overhead of an extra function call.\n            method = \"throw\";\n            arg = record.arg;\n            continue;\n          }\n\n          // Delegate generator ran and handled its own exceptions so\n          // regardless of what the method was, we continue as if it is\n          // \"next\" with an undefined arg.\n          method = \"next\";\n          arg = undefined;\n\n          var info = record.arg;\n          if (info.done) {\n            context[delegate.resultName] = info.value;\n            context.next = delegate.nextLoc;\n          } else {\n            state = GenStateSuspendedYield;\n            return info;\n          }\n\n          context.delegate = null;\n        }\n\n        if (method === \"next\") {\n          if (state === GenStateSuspendedYield) {\n            context.sent = arg;\n          } else {\n            delete context.sent;\n          }\n\n        } else if (method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw arg;\n          }\n\n          if (context.dispatchException(arg)) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            method = \"next\";\n            arg = undefined;\n          }\n\n        } else if (method === \"return\") {\n          context.abrupt(\"return\", arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          var info = {\n            value: record.arg,\n            done: context.done\n          };\n\n          if (record.arg === ContinueSentinel) {\n            if (context.delegate && method === \"next\") {\n              // Deliberately forget the last sent value so that we don't\n              // accidentally pass it on to the delegate.\n              arg = undefined;\n            }\n          } else {\n            return info;\n          }\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(arg) call above.\n          method = \"throw\";\n          arg = record.arg;\n        }\n      }\n    };\n  }\n\n  function defineGeneratorMethod(method) {\n    Gp[method] = function(arg) {\n      return this._invoke(method, arg);\n    };\n  }\n  defineGeneratorMethod(\"next\");\n  defineGeneratorMethod(\"throw\");\n  defineGeneratorMethod(\"return\");\n\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset();\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function() {\n      this.prev = 0;\n      this.next = 0;\n      this.sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      // Pre-initialize at least 20 temporary variables to enable hidden\n      // class optimizations for simple generators.\n      for (var tempIndex = 0, tempName;\n           hasOwn.call(this, tempName = \"t\" + tempIndex) || tempIndex < 20;\n           ++tempIndex) {\n        this[tempName] = null;\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.next = finallyEntry.finallyLoc;\n      } else {\n        this.complete(record);\n      }\n\n      return ContinueSentinel;\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = record.arg;\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.dav = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _co = require('co');\n\nvar _co2 = _interopRequireDefault(_co);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _calendars = require('./calendars');\n\nvar _contacts = require('./contacts');\n\nvar _fuzzy_url_equals = require('./fuzzy_url_equals');\n\nvar _fuzzy_url_equals2 = _interopRequireDefault(_fuzzy_url_equals);\n\nvar _model = require('./model');\n\nvar _namespace = require('./namespace');\n\nvar ns = _interopRequireWildcard(_namespace);\n\nvar _request = require('./request');\n\nvar request = _interopRequireWildcard(_request);\n\nvar debug = require('./debug')('dav:accounts');\n\nvar defaults = {\n  accountType: 'caldav',\n  loadCollections: true,\n  loadObjects: false\n};\n\n/**\n * rfc 6764.\n *\n * @param {dav.Account} account to find root url for.\n */\nvar serviceDiscovery = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(account, options) {\n  var endpoint, uri, req, xhr, _location;\n\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        debug('Attempt service discovery.');\n\n        endpoint = _url2['default'].parse(account.server);\n\n        endpoint.protocol = endpoint.protocol || 'http'; // TODO(gareth) https?\n\n        uri = _url2['default'].format({\n          protocol: endpoint.protocol,\n          host: endpoint.host,\n          pathname: '/.well-known/' + options.accountType\n        });\n        req = request.basic({ method: 'GET' });\n        context$1$0.prev = 5;\n        context$1$0.next = 8;\n        return options.xhr.send(req, uri, { sandbox: options.sandbox });\n\n      case 8:\n        xhr = context$1$0.sent;\n\n        if (!(xhr.status >= 300 && xhr.status < 400)) {\n          context$1$0.next = 14;\n          break;\n        }\n\n        _location = xhr.getResponseHeader('Location');\n\n        if (!(typeof _location === 'string' && _location.length)) {\n          context$1$0.next = 14;\n          break;\n        }\n\n        debug('Discovery redirected to ' + _location);\n        return context$1$0.abrupt('return', _url2['default'].format({\n          protocol: endpoint.protocol,\n          host: endpoint.host,\n          pathname: _location\n        }));\n\n      case 14:\n        context$1$0.next = 19;\n        break;\n\n      case 16:\n        context$1$0.prev = 16;\n        context$1$0.t0 = context$1$0['catch'](5);\n\n        debug('Discovery failed... failover to the provided url');\n\n      case 19:\n        return context$1$0.abrupt('return', endpoint.href);\n\n      case 20:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this, [[5, 16]]);\n}));\n\n/**\n * rfc 5397.\n *\n * @param {dav.Account} account to get principal url for.\n */\nvar principalUrl = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(account, options) {\n  var req, res, container;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        debug('Fetch principal url from context path ' + account.rootUrl + '.');\n        req = request.propfind({\n          props: [{ name: 'current-user-principal', namespace: ns.DAV }],\n          depth: 0,\n          mergeResponses: true\n        });\n        context$1$0.next = 4;\n        return options.xhr.send(req, account.rootUrl, {\n          sandbox: options.sandbox\n        });\n\n      case 4:\n        res = context$1$0.sent;\n        container = res.props;\n\n        debug('Received principal: ' + container.currentUserPrincipal);\n        return context$1$0.abrupt('return', _url2['default'].resolve(account.rootUrl, container.currentUserPrincipal));\n\n      case 8:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\n/**\n * @param {dav.Account} account to get home url for.\n */\nvar homeUrl = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(account, options) {\n  var prop, req, responses, response, container, href;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        debug('Fetch home url from principal url ' + account.principalUrl + '.');\n        prop = undefined;\n\n        if (options.accountType === 'caldav') {\n          prop = { name: 'calendar-home-set', namespace: ns.CALDAV };\n        } else if (options.accountType === 'carddav') {\n          prop = { name: 'addressbook-home-set', namespace: ns.CARDDAV };\n        }\n\n        req = request.propfind({ props: [prop] });\n        context$1$0.next = 6;\n        return options.xhr.send(req, account.principalUrl, {\n          sandbox: options.sandbox\n        });\n\n      case 6:\n        responses = context$1$0.sent;\n        response = responses.find(function (response) {\n          return (0, _fuzzy_url_equals2['default'])(account.principalUrl, response.href);\n        });\n        container = response.props;\n        href = undefined;\n\n        if (options.accountType === 'caldav') {\n          debug('Received home: ' + container.calendarHomeSet);\n          href = container.calendarHomeSet;\n        } else if (options.accountType === 'carddav') {\n          debug('Received home: ' + container.addressbookHomeSet);\n          href = container.addressbookHomeSet;\n        }\n\n        return context$1$0.abrupt('return', _url2['default'].resolve(account.rootUrl, href));\n\n      case 12:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\n/**\n * Options:\n *\n *   (String) accountType - one of 'caldav' or 'carddav'. Defaults to 'caldav'.\n *   (Array.<Object>) filters - list of caldav filters to send with request.\n *   (Boolean) loadCollections - whether or not to load dav collections.\n *   (Boolean) loadObjects - whether or not to load dav objects.\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (String) server - some url for server (needn't be base url).\n *   (String) timezone - VTIMEZONE calendar object.\n *   (dav.Transport) xhr - request sender.\n *\n * @return {Promise} a promise that will resolve with a dav.Account object.\n */\nexports.createAccount = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(options) {\n  var account, key, loadCollections, loadObjects, collections;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        options = Object.assign({}, defaults, options);\n        if (typeof options.loadObjects !== 'boolean') {\n          options.loadObjects = options.loadCollections;\n        }\n\n        account = new _model.Account({\n          server: options.server,\n          credentials: options.xhr.credentials\n        });\n        context$1$0.next = 5;\n        return serviceDiscovery(account, options);\n\n      case 5:\n        account.rootUrl = context$1$0.sent;\n        context$1$0.next = 8;\n        return principalUrl(account, options);\n\n      case 8:\n        account.principalUrl = context$1$0.sent;\n        context$1$0.next = 11;\n        return homeUrl(account, options);\n\n      case 11:\n        account.homeUrl = context$1$0.sent;\n\n        if (options.loadCollections) {\n          context$1$0.next = 14;\n          break;\n        }\n\n        return context$1$0.abrupt('return', account);\n\n      case 14:\n        key = undefined, loadCollections = undefined, loadObjects = undefined;\n\n        if (options.accountType === 'caldav') {\n          key = 'calendars';\n          loadCollections = _calendars.listCalendars;\n          loadObjects = _calendars.listCalendarObjects;\n        } else if (options.accountType === 'carddav') {\n          key = 'addressBooks';\n          loadCollections = _contacts.listAddressBooks;\n          loadObjects = _contacts.listVCards;\n        }\n\n        context$1$0.next = 18;\n        return loadCollections(account, options);\n\n      case 18:\n        collections = context$1$0.sent;\n\n        account[key] = collections;\n\n        if (options.loadObjects) {\n          context$1$0.next = 22;\n          break;\n        }\n\n        return context$1$0.abrupt('return', account);\n\n      case 22:\n        context$1$0.next = 24;\n        return collections.map(_co2['default'].wrap(regeneratorRuntime.mark(function callee$1$0(collection) {\n          return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {\n            while (1) switch (context$2$0.prev = context$2$0.next) {\n              case 0:\n                context$2$0.prev = 0;\n                context$2$0.next = 3;\n                return loadObjects(collection, options);\n\n              case 3:\n                collection.objects = context$2$0.sent;\n                context$2$0.next = 9;\n                break;\n\n              case 6:\n                context$2$0.prev = 6;\n                context$2$0.t0 = context$2$0['catch'](0);\n\n                collection.error = context$2$0.t0;\n\n              case 9:\n              case 'end':\n                return context$2$0.stop();\n            }\n          }, callee$1$0, this, [[0, 6]]);\n        })));\n\n      case 24:\n\n        account[key] = account[key].filter(function (collection) {\n          return !collection.error;\n        });\n\n        return context$1$0.abrupt('return', account);\n\n      case 26:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\n// http redirect.\n},{\"./calendars\":2,\"./contacts\":5,\"./debug\":6,\"./fuzzy_url_equals\":7,\"./model\":9,\"./namespace\":10,\"./request\":12,\"co\":29,\"url\":28}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createCalendarObject = createCalendarObject;\nexports.updateCalendarObject = updateCalendarObject;\nexports.deleteCalendarObject = deleteCalendarObject;\nexports.syncCalendar = syncCalendar;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _co = require('co');\n\nvar _co2 = _interopRequireDefault(_co);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _fuzzy_url_equals = require('./fuzzy_url_equals');\n\nvar _fuzzy_url_equals2 = _interopRequireDefault(_fuzzy_url_equals);\n\nvar _model = require('./model');\n\nvar _namespace = require('./namespace');\n\nvar ns = _interopRequireWildcard(_namespace);\n\nvar _request = require('./request');\n\nvar request = _interopRequireWildcard(_request);\n\nvar _webdav = require('./webdav');\n\nvar webdav = _interopRequireWildcard(_webdav);\n\nvar debug = require('./debug')('dav:calendars');\n\nvar ICAL_OBJS = new Set(['VEVENT', 'VTODO', 'VJOURNAL', 'VFREEBUSY', 'VTIMEZONE', 'VALARM']);\n\n/**\n * @param {dav.Account} account to fetch calendars for.\n */\nvar listCalendars = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(account, options) {\n  var req, responses, cals;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        debug('Fetch calendars from home url ' + account.homeUrl);\n        req = request.propfind({\n          props: [{ name: 'calendar-description', namespace: ns.CALDAV }, { name: 'calendar-timezone', namespace: ns.CALDAV }, { name: 'displayname', namespace: ns.DAV }, { name: 'getctag', namespace: ns.CALENDAR_SERVER }, { name: 'resourcetype', namespace: ns.DAV }, { name: 'supported-calendar-component-set', namespace: ns.CALDAV }, { name: 'sync-token', namespace: ns.DAV }],\n          depth: 1\n        });\n        context$1$0.next = 4;\n        return options.xhr.send(req, account.homeUrl, {\n          sandbox: options.sandbox\n        });\n\n      case 4:\n        responses = context$1$0.sent;\n\n        debug('Found ' + responses.length + ' calendars.');\n        cals = responses.filter(function (res) {\n          // We only want the calendar if it contains iCalendar objects.\n          var components = res.props.supportedCalendarComponentSet || [];\n          return components.reduce(function (hasObjs, component) {\n            return hasObjs || ICAL_OBJS.has(component);\n          }, false);\n        }).map(function (res) {\n          debug('Found calendar ' + res.props.displayname + ',\\n             props: ' + JSON.stringify(res.props));\n          return new _model.Calendar({\n            data: res,\n            account: account,\n            description: res.props.calendarDescription,\n            timezone: res.props.calendarTimezone,\n            url: _url2['default'].resolve(account.rootUrl, res.href),\n            ctag: res.props.getctag,\n            displayName: res.props.displayname,\n            components: res.props.supportedCalendarComponentSet,\n            resourcetype: res.props.resourcetype,\n            syncToken: res.props.syncToken\n          });\n        });\n        context$1$0.next = 9;\n        return cals.map(_co2['default'].wrap(regeneratorRuntime.mark(function callee$1$0(cal) {\n          return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {\n            while (1) switch (context$2$0.prev = context$2$0.next) {\n              case 0:\n                context$2$0.next = 2;\n                return webdav.supportedReportSet(cal, options);\n\n              case 2:\n                cal.reports = context$2$0.sent;\n\n              case 3:\n              case 'end':\n                return context$2$0.stop();\n            }\n          }, callee$1$0, this);\n        })));\n\n      case 9:\n        return context$1$0.abrupt('return', cals);\n\n      case 10:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\nexports.listCalendars = listCalendars;\n/**\n * @param {dav.Calendar} calendar the calendar to put the object on.\n * @return {Promise} promise will resolve when the calendar has been created.\n *\n * Options:\n *\n *   (String) data - rfc 5545 VCALENDAR object.\n *   (String) filename - name for the calendar ics file.\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\n\nfunction createCalendarObject(calendar, options) {\n  var objectUrl = _url2['default'].resolve(calendar.url, options.filename);\n  return webdav.createObject(objectUrl, options.data, options);\n}\n\n;\n\n/**\n * @param {dav.CalendarObject} calendarObject updated calendar object.\n * @return {Promise} promise will resolve when the calendar has been updated.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\n\nfunction updateCalendarObject(calendarObject, options) {\n  return webdav.updateObject(calendarObject.url, calendarObject.calendarData, calendarObject.etag, options);\n}\n\n/**\n * @param {dav.CalendarObject} calendarObject target calendar object.\n * @return {Promise} promise will resolve when the calendar has been deleted.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\n\nfunction deleteCalendarObject(calendarObject, options) {\n  return webdav.deleteObject(calendarObject.url, calendarObject.etag, options);\n}\n\n/**\n * @param {dav.Calendar} calendar the calendar to fetch objects for.\n *\n * Options:\n *\n *   (Array.<Object>) filters - optional caldav filters.\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\nvar listCalendarObjects = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(calendar, options) {\n  var filters, req, responses;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        debug('Doing REPORT on calendar ' + calendar.url + ' which belongs to\\n         ' + calendar.account.credentials.username);\n\n        filters = options.filters || [{\n          type: 'comp-filter',\n          attrs: { name: 'VCALENDAR' },\n          children: [{\n            type: 'comp-filter',\n            attrs: { name: 'VEVENT' }\n          }]\n        }];\n        req = request.calendarQuery({\n          depth: 1,\n          props: [{ name: 'getetag', namespace: ns.DAV }, { name: 'calendar-data', namespace: ns.CALDAV }],\n          filters: filters\n        });\n        context$1$0.next = 5;\n        return options.xhr.send(req, calendar.url, {\n          sandbox: options.sandbox\n        });\n\n      case 5:\n        responses = context$1$0.sent;\n        return context$1$0.abrupt('return', responses.map(function (res) {\n          debug('Found calendar object with url ' + res.href);\n          return new _model.CalendarObject({\n            data: res,\n            calendar: calendar,\n            url: _url2['default'].resolve(calendar.account.rootUrl, res.href),\n            etag: res.props.getetag,\n            calendarData: res.props.calendarData\n          });\n        }));\n\n      case 7:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\nexports.listCalendarObjects = listCalendarObjects;\n/**\n * @param {dav.Calendar} calendar the calendar to fetch updates to.\n * @return {Promise} promise will resolve with updated calendar object.\n *\n * Options:\n *\n *   (Array.<Object>) filters - list of caldav filters to send with request.\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (String) syncMethod - either 'basic' or 'webdav'. If unspecified, will\n *       try to do webdav sync and failover to basic sync if rfc 6578 is not\n *       supported by the server.\n *   (String) timezone - VTIMEZONE calendar object.\n *   (dav.Transport) xhr - request sender.\n */\n\nfunction syncCalendar(calendar, options) {\n  options.basicSync = basicSync;\n  options.webdavSync = webdavSync;\n  return webdav.syncCollection(calendar, options);\n}\n\n/**\n * @param {dav.Account} account the account to fetch updates for.\n * @return {Promise} promise will resolve with updated account.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\nvar syncCaldavAccount = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(account) {\n  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n  var cals;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        options.loadObjects = false;\n        if (!account.calendars) account.calendars = [];\n\n        context$1$0.next = 4;\n        return listCalendars(account, options);\n\n      case 4:\n        cals = context$1$0.sent;\n\n        cals.filter(function (cal) {\n          // Filter the calendars not previously seen.\n          return account.calendars.every(function (prev) {\n            return !(0, _fuzzy_url_equals2['default'])(prev.url, cal.url);\n          });\n        }).forEach(function (cal) {\n          // Add them to the account's calendar list.\n          account.calendars.push(cal);\n        });\n\n        options.loadObjects = true;\n        context$1$0.next = 9;\n        return account.calendars.map(_co2['default'].wrap(regeneratorRuntime.mark(function callee$1$0(cal, index) {\n          return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {\n            while (1) switch (context$2$0.prev = context$2$0.next) {\n              case 0:\n                context$2$0.prev = 0;\n                context$2$0.next = 3;\n                return syncCalendar(cal, options);\n\n              case 3:\n                context$2$0.next = 9;\n                break;\n\n              case 5:\n                context$2$0.prev = 5;\n                context$2$0.t0 = context$2$0['catch'](0);\n\n                debug('Sync calendar ' + cal.displayName + ' failed with ' + context$2$0.t0);\n                account.calendars.splice(index, 1);\n\n              case 9:\n              case 'end':\n                return context$2$0.stop();\n            }\n          }, callee$1$0, this, [[0, 5]]);\n        })));\n\n      case 9:\n        return context$1$0.abrupt('return', account);\n\n      case 10:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\nexports.syncCaldavAccount = syncCaldavAccount;\nvar basicSync = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(calendar, options) {\n  var sync;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        context$1$0.next = 2;\n        return webdav.isCollectionDirty(calendar, options);\n\n      case 2:\n        sync = context$1$0.sent;\n\n        if (sync) {\n          context$1$0.next = 6;\n          break;\n        }\n\n        debug('Local ctag matched remote! No need to sync :).');\n        return context$1$0.abrupt('return', calendar);\n\n      case 6:\n\n        debug('ctag changed so we need to fetch stuffs.');\n        context$1$0.next = 9;\n        return listCalendarObjects(calendar, options);\n\n      case 9:\n        calendar.objects = context$1$0.sent;\n        return context$1$0.abrupt('return', calendar);\n\n      case 11:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\nvar webdavSync = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(calendar, options) {\n  var req, result;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        req = request.syncCollection({\n          props: [{ name: 'getetag', namespace: ns.DAV }, { name: 'calendar-data', namespace: ns.CALDAV }],\n          syncLevel: 1,\n          syncToken: calendar.syncToken\n        });\n        context$1$0.next = 3;\n        return options.xhr.send(req, calendar.url, {\n          sandbox: options.sandbox\n        });\n\n      case 3:\n        result = context$1$0.sent;\n\n        // TODO(gareth): Handle creations and deletions.\n        result.responses.forEach(function (response) {\n          // Find the calendar object that this response corresponds with.\n          var calendarObject = calendar.objects.filter(function (object) {\n            return (0, _fuzzy_url_equals2['default'])(object.url, response.href);\n          })[0];\n\n          if (!calendarObject) {\n            return;\n          }\n\n          calendarObject.etag = response.props.getetag;\n          calendarObject.calendarData = response.props.calendarData;\n        });\n\n        calendar.syncToken = result.syncToken;\n        return context$1$0.abrupt('return', calendar);\n\n      case 7:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n},{\"./debug\":6,\"./fuzzy_url_equals\":7,\"./model\":9,\"./namespace\":10,\"./request\":12,\"./webdav\":22,\"co\":29,\"url\":28}],3:[function(require,module,exports){\n/**\n * @fileoverview Camelcase something.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = camelize;\n\nfunction camelize(str) {\n  var delimiter = arguments.length <= 1 || arguments[1] === undefined ? '_' : arguments[1];\n\n  var words = str.split(delimiter);\n  return [words[0]].concat(words.slice(1).map(function (word) {\n    return word.charAt(0).toUpperCase() + word.slice(1);\n  })).join('');\n}\n\nmodule.exports = exports['default'];\n},{}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _accounts = require('./accounts');\n\nvar accounts = _interopRequireWildcard(_accounts);\n\nvar _calendars = require('./calendars');\n\nvar calendars = _interopRequireWildcard(_calendars);\n\nvar _contacts = require('./contacts');\n\nvar contacts = _interopRequireWildcard(_contacts);\n\n/**\n * @param {dav.Transport} xhr - request sender.\n *\n * Options:\n *\n *   (String) baseUrl - root url to resolve relative request urls with.\n */\n\nvar Client = (function () {\n  function Client(xhr) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Client);\n\n    this.xhr = xhr;\n    Object.assign(this, options);\n\n    // Expose internal modules for unit testing\n    this._accounts = accounts;\n    this._calendars = calendars;\n    this._contacts = contacts;\n  }\n\n  /**\n   * @param {dav.Request} req - dav request.\n   * @param {String} uri - where to send request.\n   * @return {Promise} a promise that will be resolved with an xhr request\n   *     after its readyState is 4 or the result of applying an optional\n   *     request `transformResponse` function to the xhr object after its\n   *     readyState is 4.\n   *\n   * Options:\n   *\n   *   (Object) sandbox - optional request sandbox.\n   */\n\n  _createClass(Client, [{\n    key: 'send',\n    value: function send(req, uri, options) {\n      if (this.baseUrl) {\n        var urlObj = _url2['default'].parse(uri);\n        uri = _url2['default'].resolve(this.baseUrl, urlObj.path);\n      }\n\n      return this.xhr.send(req, uri, options);\n    }\n  }, {\n    key: 'createAccount',\n    value: function createAccount() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      options.xhr = options.xhr || this.xhr;\n      return accounts.createAccount(options);\n    }\n  }, {\n    key: 'createCalendarObject',\n    value: function createCalendarObject(calendar) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      options.xhr = options.xhr || this.xhr;\n      return calendars.createCalendarObject(calendar, options);\n    }\n  }, {\n    key: 'updateCalendarObject',\n    value: function updateCalendarObject(calendarObject) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      options.xhr = options.xhr || this.xhr;\n      return calendars.updateCalendarObject(calendarObject, options);\n    }\n  }, {\n    key: 'deleteCalendarObject',\n    value: function deleteCalendarObject(calendarObject) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      options.xhr = options.xhr || this.xhr;\n      return calendars.deleteCalendarObject(calendarObject, options);\n    }\n  }, {\n    key: 'syncCalendar',\n    value: function syncCalendar(calendar) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      options.xhr = options.xhr || this.xhr;\n      return calendars.syncCalendar(calendar, options);\n    }\n  }, {\n    key: 'syncCaldavAccount',\n    value: function syncCaldavAccount(account) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      options.xhr = options.xhr || this.xhr;\n      return calendars.syncCaldavAccount(account, options);\n    }\n  }, {\n    key: 'createCard',\n    value: function createCard(addressBook) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      options.xhr = options.xhr || this.xhr;\n      return contacts.createCard(addressBook, options);\n    }\n  }, {\n    key: 'updateCard',\n    value: function updateCard(card) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      options.xhr = options.xhr || this.xhr;\n      return contacts.updateCard(card, options);\n    }\n  }, {\n    key: 'deleteCard',\n    value: function deleteCard(card) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      options.xhr = options.xhr || this.xhr;\n      return contacts.deleteCard(card, options);\n    }\n  }, {\n    key: 'syncAddressBook',\n    value: function syncAddressBook(addressBook) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      options.xhr = options.xhr || this.xhr;\n      return contacts.syncAddressBook(addressBook, options);\n    }\n  }, {\n    key: 'syncCarddavAccount',\n    value: function syncCarddavAccount(account) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      options.xhr = options.xhr || this.xhr;\n      return contacts.syncCarddavAccount(account, options);\n    }\n  }]);\n\n  return Client;\n})();\n\nexports.Client = Client;\n},{\"./accounts\":1,\"./calendars\":2,\"./contacts\":5,\"url\":28}],5:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createCard = createCard;\nexports.updateCard = updateCard;\nexports.deleteCard = deleteCard;\nexports.syncAddressBook = syncAddressBook;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _co = require('co');\n\nvar _co2 = _interopRequireDefault(_co);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _fuzzy_url_equals = require('./fuzzy_url_equals');\n\nvar _fuzzy_url_equals2 = _interopRequireDefault(_fuzzy_url_equals);\n\nvar _model = require('./model');\n\nvar _namespace = require('./namespace');\n\nvar ns = _interopRequireWildcard(_namespace);\n\nvar _request = require('./request');\n\nvar request = _interopRequireWildcard(_request);\n\nvar _webdav = require('./webdav');\n\nvar webdav = _interopRequireWildcard(_webdav);\n\nvar debug = require('./debug')('dav:contacts');\n\n/**\n * @param {dav.Account} account to fetch address books for.\n */\nvar listAddressBooks = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(account, options) {\n  var req, responses, addressBooks;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        debug('Fetch address books from home url ' + account.homeUrl);\n        req = request.propfind({\n          props: [{ name: 'displayname', namespace: ns.DAV }, { name: 'getctag', namespace: ns.CALENDAR_SERVER }, { name: 'resourcetype', namespace: ns.DAV }, { name: 'sync-token', namespace: ns.DAV }],\n          depth: 1\n        });\n        context$1$0.next = 4;\n        return options.xhr.send(req, account.homeUrl, {\n          sandbox: options.sandbox\n        });\n\n      case 4:\n        responses = context$1$0.sent;\n        addressBooks = responses.filter(function (res) {\n          return typeof res.props.displayname === 'string';\n        }).map(function (res) {\n          debug('Found address book named ' + res.props.displayname + ',\\n             props: ' + JSON.stringify(res.props));\n          return new _model.AddressBook({\n            data: res,\n            account: account,\n            url: _url2['default'].resolve(account.rootUrl, res.href),\n            ctag: res.props.getctag,\n            displayName: res.props.displayname,\n            resourcetype: res.props.resourcetype,\n            syncToken: res.props.syncToken\n          });\n        });\n        context$1$0.next = 8;\n        return addressBooks.map(_co2['default'].wrap(regeneratorRuntime.mark(function callee$1$0(addressBook) {\n          return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {\n            while (1) switch (context$2$0.prev = context$2$0.next) {\n              case 0:\n                context$2$0.next = 2;\n                return webdav.supportedReportSet(addressBook, options);\n\n              case 2:\n                addressBook.reports = context$2$0.sent;\n\n              case 3:\n              case 'end':\n                return context$2$0.stop();\n            }\n          }, callee$1$0, this);\n        })));\n\n      case 8:\n        return context$1$0.abrupt('return', addressBooks);\n\n      case 9:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\nexports.listAddressBooks = listAddressBooks;\n/**\n * @param {dav.AddressBook} addressBook the address book to put the object on.\n * @return {Promise} promise will resolve when the card has been created.\n *\n * Options:\n *\n *   (String) data - vcard object.\n *   (String) filename - name for the address book vcf file.\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\n\nfunction createCard(addressBook, options) {\n  var objectUrl = _url2['default'].resolve(addressBook.url, options.filename);\n  return webdav.createObject(objectUrl, options.data, options);\n}\n\n/**\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n */\nvar listVCards = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(addressBook, options) {\n  var req, responses;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        debug('Doing REPORT on address book ' + addressBook.url + ' which belongs to\\n        ' + addressBook.account.credentials.username);\n\n        req = request.addressBookQuery({\n          depth: 1,\n          props: [{ name: 'getetag', namespace: ns.DAV }, { name: 'address-data', namespace: ns.CARDDAV }]\n        });\n        context$1$0.next = 4;\n        return options.xhr.send(req, addressBook.url, {\n          sandbox: options.sandbox\n        });\n\n      case 4:\n        responses = context$1$0.sent;\n        return context$1$0.abrupt('return', responses.map(function (res) {\n          debug('Found vcard with url ' + res.href);\n          return new _model.VCard({\n            data: res,\n            addressBook: addressBook,\n            url: _url2['default'].resolve(addressBook.account.rootUrl, res.href),\n            etag: res.props.getetag,\n            addressData: res.props.addressData\n          });\n        }));\n\n      case 6:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\nexports.listVCards = listVCards;\n/**\n * @param {dav.VCard} card updated vcard object.\n * @return {Promise} promise will resolve when the card has been updated.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\n\nfunction updateCard(card, options) {\n  return webdav.updateObject(card.url, card.addressData, card.etag, options);\n}\n\n/**\n * @param {dav.VCard} card target vcard object.\n * @return {Promise} promise will resolve when the calendar has been deleted.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\n\nfunction deleteCard(card, options) {\n  return webdav.deleteObject(card.url, card.etag, options);\n}\n\n/**\n * @param {dav.Calendar} calendar the calendar to fetch updates to.\n * @return {Promise} promise will resolve with updated calendar object.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (String) syncMethod - either 'basic' or 'webdav'. If unspecified, will\n *       try to do webdav sync and failover to basic sync if rfc 6578 is not\n *       supported by the server.\n *   (dav.Transport) xhr - request sender.\n */\n\nfunction syncAddressBook(addressBook, options) {\n  options.basicSync = basicSync;\n  options.webdavSync = webdavSync;\n  return webdav.syncCollection(addressBook, options);\n}\n\n/**\n * @param {dav.Account} account the account to fetch updates for.\n * @return {Promise} promise will resolve with updated account.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\nvar syncCarddavAccount = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(account) {\n  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n  var addressBooks;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        options.loadObjects = false;\n\n        if (!account.addressBooks) {\n          account.addressBooks = [];\n        }\n\n        context$1$0.next = 4;\n        return listAddressBooks(account, options);\n\n      case 4:\n        addressBooks = context$1$0.sent;\n\n        addressBooks.filter(function (addressBook) {\n          // Filter the address books not previously seen.\n          return account.addressBooks.every(function (prev) {\n            return !(0, _fuzzy_url_equals2['default'])(prev.url, addressBook.url);\n          });\n        }).forEach(function (addressBook) {\n          return account.addressBooks.push(addressBook);\n        });\n\n        options.loadObjects = true;\n        context$1$0.next = 9;\n        return account.addressBooks.map(_co2['default'].wrap(regeneratorRuntime.mark(function callee$1$0(addressBook, index) {\n          return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {\n            while (1) switch (context$2$0.prev = context$2$0.next) {\n              case 0:\n                context$2$0.prev = 0;\n                context$2$0.next = 3;\n                return syncAddressBook(addressBook, options);\n\n              case 3:\n                context$2$0.next = 9;\n                break;\n\n              case 5:\n                context$2$0.prev = 5;\n                context$2$0.t0 = context$2$0['catch'](0);\n\n                debug('Syncing ' + addressBook.displayName + ' failed with ' + context$2$0.t0);\n                account.addressBooks.splice(index, 1);\n\n              case 9:\n              case 'end':\n                return context$2$0.stop();\n            }\n          }, callee$1$0, this, [[0, 5]]);\n        })));\n\n      case 9:\n        return context$1$0.abrupt('return', account);\n\n      case 10:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\nexports.syncCarddavAccount = syncCarddavAccount;\nvar basicSync = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(addressBook, options) {\n  var sync;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        sync = webdav.isCollectionDirty(addressBook, options);\n\n        if (sync) {\n          context$1$0.next = 4;\n          break;\n        }\n\n        debug('Local ctag matched remote! No need to sync :).');\n        return context$1$0.abrupt('return', addressBook);\n\n      case 4:\n\n        debug('ctag changed so we need to fetch stuffs.');\n        context$1$0.next = 7;\n        return listVCards(addressBook, options);\n\n      case 7:\n        addressBook.objects = context$1$0.sent;\n        return context$1$0.abrupt('return', addressBook);\n\n      case 9:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\nvar webdavSync = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(addressBook, options) {\n  var req, result;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        req = request.syncCollection({\n          props: [{ name: 'getetag', namespace: ns.DAV }, { name: 'address-data', namespace: ns.CARDDAV }],\n          syncLevel: 1,\n          syncToken: addressBook.syncToken\n        });\n        context$1$0.next = 3;\n        return options.xhr.send(req, addressBook.url, {\n          sandbox: options.sandbox\n        });\n\n      case 3:\n        result = context$1$0.sent;\n\n        // TODO(gareth): Handle creations and deletions.\n        result.responses.forEach(function (response) {\n          // Find the vcard that this response corresponds with.\n          var vcard = addressBook.objects.filter(function (object) {\n            return (0, _fuzzy_url_equals2['default'])(object.url, response.href);\n          })[0];\n\n          if (!vcard) return;\n\n          vcard.etag = response.props.getetag;\n          vcard.addressData = response.props.addressData;\n        });\n\n        addressBook.syncToken = result.syncToken;\n        return context$1$0.abrupt('return', addressBook);\n\n      case 7:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n},{\"./debug\":6,\"./fuzzy_url_equals\":7,\"./model\":9,\"./namespace\":10,\"./request\":12,\"./webdav\":22,\"co\":29,\"url\":28}],6:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = debug;\n\nfunction debug(topic) {\n  return function (message) {\n    if (debug.enabled) {\n      console.log(\"[\" + topic + \"] \" + message);\n    }\n  };\n}\n\nmodule.exports = exports[\"default\"];\n},{}],7:[function(require,module,exports){\n'use strict';\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = fuzzyUrlEquals;\n\nfunction fuzzyUrlEquals(one, other) {\n  return fuzzyIncludes(one, other) || fuzzyIncludes(other, one);\n}\n\n;\n\nfunction fuzzyIncludes(one, other) {\n  return one.indexOf(other) !== -1 || other.charAt(other.length - 1) === '/' && one.indexOf(other.slice(0, -1)) !== -1;\n}\nmodule.exports = exports['default'];\n},{}],8:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopExportWildcard(obj, defaults) { var newObj = defaults({}, obj); delete newObj['default']; return newObj; }\n\nfunction _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _debug = require('./debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _namespace = require('./namespace');\n\nvar ns = _interopRequireWildcard(_namespace);\n\nvar _request = require('./request');\n\nvar request = _interopRequireWildcard(_request);\n\nvar _transport = require('./transport');\n\nvar transport = _interopRequireWildcard(_transport);\n\nvar _package = require('../package');\n\nObject.defineProperty(exports, 'version', {\n  enumerable: true,\n  get: function get() {\n    return _package.version;\n  }\n});\n\nvar _accounts = require('./accounts');\n\nObject.defineProperty(exports, 'createAccount', {\n  enumerable: true,\n  get: function get() {\n    return _accounts.createAccount;\n  }\n});\n\nvar _calendars = require('./calendars');\n\n_defaults(exports, _interopExportWildcard(_calendars, _defaults));\n\nvar _client = require('./client');\n\nObject.defineProperty(exports, 'Client', {\n  enumerable: true,\n  get: function get() {\n    return _client.Client;\n  }\n});\n\nvar _contacts = require('./contacts');\n\n_defaults(exports, _interopExportWildcard(_contacts, _defaults));\n\nvar _model = require('./model');\n\n_defaults(exports, _interopExportWildcard(_model, _defaults));\n\nObject.defineProperty(exports, 'Request', {\n  enumerable: true,\n  get: function get() {\n    return _request.Request;\n  }\n});\n\nvar _sandbox = require('./sandbox');\n\nObject.defineProperty(exports, 'Sandbox', {\n  enumerable: true,\n  get: function get() {\n    return _sandbox.Sandbox;\n  }\n});\nObject.defineProperty(exports, 'createSandbox', {\n  enumerable: true,\n  get: function get() {\n    return _sandbox.createSandbox;\n  }\n});\nexports.debug = _debug2['default'];\nexports.ns = ns;\nexports.request = request;\nexports.transport = transport;\n},{\"../package\":33,\"./accounts\":1,\"./calendars\":2,\"./client\":4,\"./contacts\":5,\"./debug\":6,\"./model\":9,\"./namespace\":10,\"./request\":12,\"./sandbox\":13,\"./transport\":21}],9:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Account = function Account(options) {\n  _classCallCheck(this, Account);\n\n  Object.assign(this, {\n    server: null,\n    credentials: null,\n    rootUrl: null,\n    principalUrl: null,\n    homeUrl: null,\n    calendars: null,\n    addressBooks: null\n  }, options);\n}\n\n/**\n * Options:\n *   (String) username - username (perhaps email) for calendar user.\n *   (String) password - plaintext password for calendar user.\n *   (String) clientId - oauth client id.\n *   (String) clientSecret - oauth client secret.\n *   (String) authorizationCode - oauth code.\n *   (String) redirectUrl - oauth redirect url.\n *   (String) tokenUrl - oauth token url.\n *   (String) accessToken - oauth access token.\n *   (String) refreshToken - oauth refresh token.\n *   (Number) expiration - unix time for access token expiration.\n */\n;\n\nexports.Account = Account;\n\nvar Credentials = function Credentials(options) {\n  _classCallCheck(this, Credentials);\n\n  Object.assign(this, {\n    username: null,\n    password: null,\n    clientId: null,\n    clientSecret: null,\n    authorizationCode: null,\n    redirectUrl: null,\n    tokenUrl: null,\n    accessToken: null,\n    refreshToken: null,\n    expiration: null\n  }, options);\n};\n\nexports.Credentials = Credentials;\n\nvar DAVCollection = function DAVCollection(options) {\n  _classCallCheck(this, DAVCollection);\n\n  Object.assign(this, {\n    data: null,\n    objects: null,\n    account: null,\n    ctag: null,\n    description: null,\n    displayName: null,\n    reports: null,\n    resourcetype: null,\n    syncToken: null,\n    url: null\n  }, options);\n};\n\nexports.DAVCollection = DAVCollection;\n\nvar AddressBook = (function (_DAVCollection) {\n  _inherits(AddressBook, _DAVCollection);\n\n  function AddressBook(options) {\n    _classCallCheck(this, AddressBook);\n\n    _get(Object.getPrototypeOf(AddressBook.prototype), \"constructor\", this).call(this, options);\n  }\n\n  return AddressBook;\n})(DAVCollection);\n\nexports.AddressBook = AddressBook;\n\nvar Calendar = (function (_DAVCollection2) {\n  _inherits(Calendar, _DAVCollection2);\n\n  function Calendar(options) {\n    _classCallCheck(this, Calendar);\n\n    _get(Object.getPrototypeOf(Calendar.prototype), \"constructor\", this).call(this, options);\n    Object.assign(this, {\n      components: null,\n      timezone: null\n    }, options);\n  }\n\n  return Calendar;\n})(DAVCollection);\n\nexports.Calendar = Calendar;\n\nvar DAVObject = function DAVObject(options) {\n  _classCallCheck(this, DAVObject);\n\n  Object.assign(this, {\n    data: null,\n    etag: null,\n    url: null\n  }, options);\n};\n\nexports.DAVObject = DAVObject;\n\nvar CalendarObject = (function (_DAVObject) {\n  _inherits(CalendarObject, _DAVObject);\n\n  function CalendarObject(options) {\n    _classCallCheck(this, CalendarObject);\n\n    _get(Object.getPrototypeOf(CalendarObject.prototype), \"constructor\", this).call(this, options);\n    Object.assign(this, {\n      calendar: null,\n      calendarData: null\n    }, options);\n  }\n\n  return CalendarObject;\n})(DAVObject);\n\nexports.CalendarObject = CalendarObject;\n\nvar VCard = (function (_DAVObject2) {\n  _inherits(VCard, _DAVObject2);\n\n  function VCard(options) {\n    _classCallCheck(this, VCard);\n\n    _get(Object.getPrototypeOf(VCard.prototype), \"constructor\", this).call(this, options);\n    Object.assign(this, {\n      addressBook: null,\n      addressData: null\n    }, options);\n  }\n\n  return VCard;\n})(DAVObject);\n\nexports.VCard = VCard;\n},{}],10:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar CALENDAR_SERVER = 'http://calendarserver.org/ns/';\nexports.CALENDAR_SERVER = CALENDAR_SERVER;\nvar CALDAV = 'urn:ietf:params:xml:ns:caldav';\nexports.CALDAV = CALDAV;\nvar CARDDAV = 'urn:ietf:params:xml:ns:carddav';\nexports.CARDDAV = CARDDAV;\nvar DAV = 'DAV:';\nexports.DAV = DAV;\n},{}],11:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.multistatus = multistatus;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _camelize = require('./camelize');\n\nvar _camelize2 = _interopRequireDefault(_camelize);\n\nvar debug = require('./debug')('dav:parser');\n\nvar DOMParser = undefined;\nif (typeof self !== 'undefined' && 'DOMParser' in self) {\n  // browser main thread\n  DOMParser = self.DOMParser;\n} else {\n  // nodejs or web worker\n  DOMParser = require('xmldom').DOMParser;\n}\n\nfunction multistatus(string) {\n  var parser = new DOMParser();\n  var doc = parser.parseFromString(string, 'text/xml');\n  var result = traverse.multistatus(child(doc, 'multistatus'));\n  debug('input:\\n' + string + '\\noutput:\\n' + JSON.stringify(result) + '\\n');\n  return result;\n}\n\nvar traverse = {\n  // { response: [x, y, z] }\n  multistatus: function multistatus(node) {\n    return complex(node, { response: true });\n  },\n\n  // { propstat: [x, y, z] }\n  response: function response(node) {\n    return complex(node, { propstat: true, href: false });\n  },\n\n  // { prop: x }\n  propstat: function propstat(node) {\n    return complex(node, { prop: false });\n  },\n\n  // {\n  //   resourcetype: x\n  //   supportedCalendarComponentSet: y,\n  //   supportedReportSet: z\n  // }\n  prop: function prop(node) {\n    return complex(node, {\n      resourcetype: false,\n      supportedCalendarComponentSet: false,\n      supportedReportSet: false,\n      currentUserPrincipal: false\n    });\n  },\n\n  resourcetype: function resourcetype(node) {\n    return childNodes(node).map(function (childNode) {\n      return childNode.localName;\n    });\n  },\n\n  // [x, y, z]\n  supportedCalendarComponentSet: function supportedCalendarComponentSet(node) {\n    return complex(node, { comp: true }, 'comp');\n  },\n\n  // [x, y, z]\n  supportedReportSet: function supportedReportSet(node) {\n    return complex(node, { supportedReport: true }, 'supportedReport');\n  },\n\n  comp: function comp(node) {\n    return node.getAttribute('name');\n  },\n\n  // x\n  supportedReport: function supportedReport(node) {\n    return complex(node, { report: false }, 'report');\n  },\n\n  report: function report(node) {\n    return childNodes(node).map(function (childNode) {\n      return childNode.localName;\n    });\n  },\n\n  href: function href(node) {\n    return decodeURIComponent(childNodes(node)[0].nodeValue);\n  },\n\n  currentUserPrincipal: function currentUserPrincipal(node) {\n    return complex(node, { href: false }, 'href');\n  }\n};\n\nfunction complex(node, childspec, collapse) {\n  var result = {};\n  for (var key in childspec) {\n    if (childspec[key]) {\n      // Create array since we're expecting multiple.\n      result[key] = [];\n    }\n  }\n\n  childNodes(node).forEach(function (childNode) {\n    return traverseChild(node, childNode, childspec, result);\n  });\n\n  return maybeCollapse(result, childspec, collapse);\n}\n\n/**\n * Parse child childNode of node with childspec and write outcome to result.\n */\nfunction traverseChild(node, childNode, childspec, result) {\n  if (childNode.nodeType === 3 && /^\\s+$/.test(childNode.nodeValue)) {\n    // Whitespace... nothing to do.\n    return;\n  }\n\n  var localName = (0, _camelize2['default'])(childNode.localName, '-');\n  if (!(localName in childspec)) {\n    debug('Unexpected node of type ' + localName + ' encountered while ' + 'parsing ' + node.localName + ' node!');\n    var value = childNode.textContent;\n    if (localName in result) {\n      if (!Array.isArray(result[camelCase])) {\n        // Since we've already encountered this node type and we haven't yet\n        // made an array for it, make an array now.\n        result[localName] = [result[localName]];\n      }\n\n      result[localName].push(value);\n      return;\n    }\n\n    // First time we're encountering this node.\n    result[localName] = value;\n    return;\n  }\n\n  var traversal = traverse[localName](childNode);\n  if (childspec[localName]) {\n    // Expect multiple.\n    result[localName].push(traversal);\n  } else {\n    // Expect single.\n    result[localName] = traversal;\n  }\n}\n\nfunction maybeCollapse(result, childspec, collapse) {\n  if (!collapse) {\n    return result;\n  }\n\n  if (!childspec[collapse]) {\n    return result[collapse];\n  }\n\n  // Collapse array.\n  return result[collapse].reduce(function (a, b) {\n    return a.concat(b);\n  }, []);\n}\n\nfunction childNodes(node) {\n  var result = node.childNodes;\n  if (!Array.isArray(result)) {\n    result = Array.prototype.slice.call(result);\n  }\n\n  return result;\n}\n\nfunction children(node, localName) {\n  return childNodes(node).filter(function (childNode) {\n    return childNode.localName === localName;\n  });\n}\n\nfunction child(node, localName) {\n  return children(node, localName)[0];\n}\n},{\"./camelize\":3,\"./debug\":6,\"xmldom\":30}],12:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.addressBookQuery = addressBookQuery;\nexports.basic = basic;\nexports.calendarQuery = calendarQuery;\nexports.collectionQuery = collectionQuery;\nexports.propfind = propfind;\nexports.syncCollection = syncCollection;\nexports.mergeProps = mergeProps;\nexports.getProps = getProps;\nexports.setRequestHeaders = setRequestHeaders;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _parser = require('./parser');\n\nvar _template = require('./template');\n\nvar template = _interopRequireWildcard(_template);\n\n/**\n * Options:\n *\n *   (String) depth - optional value for Depth header.\n *   (Array.<Object>) props - list of props to request.\n */\n\nfunction addressBookQuery(options) {\n  return collectionQuery(template.addressBookQuery({ props: options.props || [] }), { depth: options.depth });\n}\n\n/**\n * Options:\n *\n *   (String) data - put request body.\n *   (String) method - http method.\n *   (String) etag - cached calendar object etag.\n */\n\nfunction basic(options) {\n  function transformRequest(xhr) {\n    setRequestHeaders(xhr, options);\n  }\n\n  return new Request({\n    method: options.method,\n    requestData: options.data,\n    transformRequest: transformRequest\n  });\n}\n\n/**\n * Options:\n *\n *   (String) depth - optional value for Depth header.\n *   (Array.<Object>) filters - list of filters to send with request.\n *   (Array.<Object>) props - list of props to request.\n *   (String) timezone - VTIMEZONE calendar object.\n */\n\nfunction calendarQuery(options) {\n  return collectionQuery(template.calendarQuery({\n    props: options.props || [],\n    filters: options.filters || [],\n    timezone: options.timezone\n  }), {\n    depth: options.depth\n  });\n}\n\nfunction collectionQuery(requestData, options) {\n  function transformRequest(xhr) {\n    setRequestHeaders(xhr, options);\n  }\n\n  function transformResponse(xhr) {\n    return (0, _parser.multistatus)(xhr.responseText).response.map(function (res) {\n      return { href: res.href, props: getProps(res.propstat) };\n    });\n  }\n\n  return new Request({\n    method: 'REPORT',\n    requestData: requestData,\n    transformRequest: transformRequest,\n    transformResponse: transformResponse\n  });\n}\n\n/**\n * Options:\n *\n *   (String) depth - optional value for Depth header.\n *   (Array.<Object>) props - list of props to request.\n */\n\nfunction propfind(options) {\n  var requestData = template.propfind({ props: options.props });\n\n  function transformRequest(xhr) {\n    setRequestHeaders(xhr, options);\n  }\n\n  function transformResponse(xhr) {\n    var responses = (0, _parser.multistatus)(xhr.responseText).response.map(function (res) {\n      return { href: res.href, props: getProps(res.propstat) };\n    });\n\n    if (!options.mergeResponses) {\n      return responses;\n    }\n\n    // Merge the props.\n    var merged = mergeProps(responses.map(function (res) {\n      return res.props;\n    }));\n    var hrefs = responses.map(function (res) {\n      return res.href;\n    });\n    return { props: merged, hrefs: hrefs };\n  }\n\n  return new Request({\n    method: 'PROPFIND',\n    requestData: requestData,\n    transformRequest: transformRequest,\n    transformResponse: transformResponse\n  });\n}\n\n/**\n * Options:\n *\n *   (String) depth - option value for Depth header.\n *   (Array.<Object>) props - list of props to request.\n *   (Number) syncLevel - indicates scope of the sync report request.\n *   (String) syncToken - synchronization token provided by the server.\n */\n\nfunction syncCollection(options) {\n  var requestData = template.syncCollection({\n    props: options.props,\n    syncLevel: options.syncLevel,\n    syncToken: options.syncToken\n  });\n\n  function transformRequest(xhr) {\n    setRequestHeaders(xhr, options);\n  }\n\n  function transformResponse(xhr) {\n    var object = (0, _parser.multistatus)(xhr.responseText);\n    var responses = object.response.map(function (res) {\n      return { href: res.href, props: getProps(res.propstat) };\n    });\n\n    return { responses: responses, syncToken: object.syncToken };\n  }\n\n  return new Request({\n    method: 'REPORT',\n    requestData: requestData,\n    transformRequest: transformRequest,\n    transformResponse: transformResponse\n  });\n}\n\nvar Request = function Request() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  _classCallCheck(this, Request);\n\n  Object.assign(this, {\n    method: null,\n    requestData: null,\n    transformRequest: null,\n    transformResponse: null,\n    onerror: null\n  }, options);\n};\n\nexports.Request = Request;\n\nfunction getProp(propstat) {\n  if (/404/g.test(propstat.status)) {\n    return null;\n  }\n  if (/5\\d{2}/g.test(propstat.status) || /4\\d{2}/g.test(propstat.status)) {\n    throw new Error('Bad status on propstat: ' + propstat.status);\n  }\n\n  return 'prop' in propstat ? propstat.prop : null;\n}\n\nfunction mergeProps(props) {\n  return props.reduce(function (a, b) {\n    return Object.assign(a, b);\n  }, {});\n}\n\n/**\n * Map propstats to props.\n */\n\nfunction getProps(propstats) {\n  return mergeProps(propstats.map(getProp).filter(function (prop) {\n    return prop && typeof prop === 'object';\n  }));\n}\n\nfunction setRequestHeaders(request, options) {\n  request.setRequestHeader('Content-Type', 'application/xml;charset=utf-8');\n\n  if ('depth' in options) {\n    request.setRequestHeader('Depth', options.depth);\n  }\n\n  if ('etag' in options) {\n    request.setRequestHeader('If-Match', options.etag);\n  }\n}\n},{\"./parser\":11,\"./template\":17}],13:[function(require,module,exports){\n/**\n * @fileoverview Group requests together and then abort as a group.\n *\n * var sandbox = new dav.Sandbox();\n * return Promise.all([\n *   dav.createEvent(event, { sandbox: sandbox }),\n *   dav.deleteEvent(other, { sandbox: sandbox })\n * ])\n * .catch(function() {\n *   // Something went wrong so abort all requests.\n *   sandbox.abort;\n * });\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.createSandbox = createSandbox;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar debug = require('./debug')('dav:sandbox');\n\nvar Sandbox = (function () {\n  function Sandbox() {\n    _classCallCheck(this, Sandbox);\n\n    this.requestList = [];\n  }\n\n  _createClass(Sandbox, [{\n    key: 'add',\n    value: function add(request) {\n      debug('Adding request to sandbox.');\n      this.requestList.push(request);\n    }\n  }, {\n    key: 'abort',\n    value: function abort() {\n      debug('Aborting sandboxed requests.');\n      this.requestList.forEach(function (request) {\n        return request.abort();\n      });\n    }\n  }]);\n\n  return Sandbox;\n})();\n\nexports.Sandbox = Sandbox;\n\nfunction createSandbox() {\n  return new Sandbox();\n}\n},{\"./debug\":6}],14:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = addressBookQuery;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _prop = require('./prop');\n\nvar _prop2 = _interopRequireDefault(_prop);\n\nfunction addressBookQuery(object) {\n  return '<card:addressbook-query xmlns:card=\"urn:ietf:params:xml:ns:carddav\"\\n                          xmlns:d=\"DAV:\">\\n    <d:prop>\\n      ' + object.props.map(_prop2['default']) + '\\n    </d:prop>\\n    <!-- According to http://stackoverflow.com/questions/23742568/google-carddav-api-addressbook-multiget-returns-400-bad-request,\\n         Google\\'s CardDAV server requires a filter element. I don\\'t think all addressbook-query calls need a filter in the spec though? -->\\n    <card:filter>\\n      <card:prop-filter name=\"FN\">\\n      </card:prop-filter>\\n    </card:filter>\\n  </card:addressbook-query>';\n}\n\nmodule.exports = exports['default'];\n},{\"./prop\":18}],15:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = calendarQuery;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _filter = require('./filter');\n\nvar _filter2 = _interopRequireDefault(_filter);\n\nvar _prop = require('./prop');\n\nvar _prop2 = _interopRequireDefault(_prop);\n\nfunction calendarQuery(object) {\n  return '<c:calendar-query xmlns:c=\"urn:ietf:params:xml:ns:caldav\"\\n                    xmlns:cs=\"http://calendarserver.org/ns/\"\\n                    xmlns:d=\"DAV:\">\\n    <d:prop>\\n      ' + object.props.map(_prop2['default']) + '\\n    </d:prop>\\n    <c:filter>\\n      ' + object.filters.map(_filter2['default']) + '\\n    </c:filter>\\n    ' + (object.timezone ? '<c:timezone>' + object.timezone + '</c:timezone>' : '') + '\\n  </c:calendar-query>';\n}\n\nmodule.exports = exports['default'];\n},{\"./filter\":16,\"./prop\":18}],16:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = filter;\n\nfunction filter(item) {\n  if (!item.children || !item.children.length) {\n    return '<c:' + item.type + ' ' + formatAttrs(item.attrs) + '/>';\n  }\n\n  var children = item.children.map(filter);\n  return '<c:' + item.type + ' ' + formatAttrs(item.attrs) + '>\\n            ' + children + '\\n          </c:' + item.type + '>';\n}\n\nfunction formatAttrs(attrs) {\n  if (typeof attrs !== 'object') {\n    return '';\n  }\n\n  return Object.keys(attrs).map(function (attr) {\n    return attr + '=\"' + attrs[attr] + '\"';\n  }).join(' ');\n}\nmodule.exports = exports['default'];\n},{}],17:[function(require,module,exports){\n'use strict';\n\nexports.addressBookQuery = require('./address_book_query');\nexports.calendarQuery = require('./calendar_query');\nexports.propfind = require('./propfind');\nexports.syncCollection = require('./sync_collection');\n},{\"./address_book_query\":14,\"./calendar_query\":15,\"./propfind\":19,\"./sync_collection\":20}],18:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = prop;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nvar _namespace = require('../namespace');\n\nvar ns = _interopRequireWildcard(_namespace);\n\n/**\n * @param {Object} filter looks like\n *\n *     {\n *       type: 'comp-filter',\n *       attrs: {\n *         name: 'VCALENDAR'\n *       }\n *     }\n *\n * Or maybe\n *\n *     {\n *       type: 'time-range',\n *       attrs: {\n *         start: '20060104T000000Z',\n *         end: '20060105T000000Z'\n *       }\n *     }\n *\n * You can nest them like so:\n *\n *     {\n *       type: 'comp-filter',\n *       attrs: { name: 'VCALENDAR' },\n *       children: [{\n *         type: 'comp-filter',\n *         attrs: { name: 'VEVENT' },\n *         children: [{\n *           type: 'time-range',\n *           attrs: { start: '20060104T000000Z', end: '20060105T000000Z' }\n *         }]\n *       }]\n *     }\n */\n\nfunction prop(item) {\n  return '<' + xmlnsPrefix(item.namespace) + ':' + item.name + ' />';\n}\n\nfunction xmlnsPrefix(namespace) {\n  switch (namespace) {\n    case ns.DAV:\n      return 'd';\n    case ns.CALENDAR_SERVER:\n      return 'cs';\n    case ns.CALDAV:\n      return 'c';\n    case ns.CARDDAV:\n      return 'card';\n    default:\n      throw new Error('Unrecognized xmlns ' + namespace);\n  }\n}\nmodule.exports = exports['default'];\n},{\"../namespace\":10}],19:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = propfind;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _prop = require('./prop');\n\nvar _prop2 = _interopRequireDefault(_prop);\n\nfunction propfind(object) {\n  return '<d:propfind xmlns:c=\"urn:ietf:params:xml:ns:caldav\"\\n              xmlns:card=\"urn:ietf:params:xml:ns:carddav\"\\n              xmlns:cs=\"http://calendarserver.org/ns/\"\\n              xmlns:d=\"DAV:\">\\n    <d:prop>\\n      ' + object.props.map(_prop2['default']) + '\\n    </d:prop>\\n  </d:propfind>';\n}\n\nmodule.exports = exports['default'];\n},{\"./prop\":18}],20:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = syncCollection;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _prop = require('./prop');\n\nvar _prop2 = _interopRequireDefault(_prop);\n\nfunction syncCollection(object) {\n  return '<d:sync-collection xmlns:c=\"urn:ietf:params:xml:ns:caldav\"\\n                     xmlns:card=\"urn:ietf:params:xml:ns:carddav\"\\n                     xmlns:d=\"DAV:\">\\n    <d:sync-level>' + object.syncLevel + '</d:sync-level>\\n    <d:sync-token>' + object.syncToken + '</d:sync-token>\\n    <d:prop>\\n      ' + object.props.map(_prop2['default']) + '\\n    </d:prop>\\n  </d:sync-collection>';\n}\n\nmodule.exports = exports['default'];\n},{\"./prop\":18}],21:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _co = require('co');\n\nvar _co2 = _interopRequireDefault(_co);\n\nvar _querystring = require('querystring');\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _xmlhttprequest = require('./xmlhttprequest');\n\nvar _xmlhttprequest2 = _interopRequireDefault(_xmlhttprequest);\n\nvar Transport = (function () {\n  /**\n   * @param {dav.Credentials} credentials user authorization.\n   */\n\n  function Transport(credentials) {\n    _classCallCheck(this, Transport);\n\n    this.credentials = credentials || null;\n  }\n\n  /**\n   * @param {dav.Request} request object with request info.\n   * @return {Promise} a promise that will be resolved with an xhr request after\n   *     its readyState is 4 or the result of applying an optional request\n   *     `transformResponse` function to the xhr object after its readyState is 4.\n   *\n   * Options:\n   *\n   *   (Object) sandbox - optional request sandbox.\n   */\n\n  _createClass(Transport, [{\n    key: 'send',\n    value: function send() {}\n  }]);\n\n  return Transport;\n})();\n\nexports.Transport = Transport;\n\nvar Basic = (function (_Transport) {\n  _inherits(Basic, _Transport);\n\n  /**\n   * @param {dav.Credentials} credentials user authorization.\n   */\n\n  function Basic(credentials) {\n    _classCallCheck(this, Basic);\n\n    _get(Object.getPrototypeOf(Basic.prototype), 'constructor', this).call(this, credentials);\n  }\n\n  /**\n   * @param {dav.Credentials} credentials user authorization.\n   */\n\n  _createClass(Basic, [{\n    key: 'send',\n    value: function send(request, url, options) {\n      return (0, _co2['default'])(regeneratorRuntime.mark(function callee$2$0() {\n        var sandbox, transformRequest, transformResponse, onerror, xhr, result;\n        return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {\n          while (1) switch (context$3$0.prev = context$3$0.next) {\n            case 0:\n              sandbox = options && options.sandbox;\n              transformRequest = request.transformRequest;\n              transformResponse = request.transformResponse;\n              onerror = request.onerror;\n              xhr = new _xmlhttprequest2['default']();\n\n              if (sandbox) sandbox.add(xhr);\n              xhr.open(request.method, url, true, /* async */\n              this.credentials.username, this.credentials.password);\n\n              if (transformRequest) transformRequest(xhr);\n\n              result = undefined;\n              context$3$0.prev = 9;\n              context$3$0.next = 12;\n              return xhr.send(request.requestData);\n\n            case 12:\n              result = transformResponse ? transformResponse(xhr) : xhr;\n              context$3$0.next = 19;\n              break;\n\n            case 15:\n              context$3$0.prev = 15;\n              context$3$0.t0 = context$3$0['catch'](9);\n\n              if (onerror) onerror(context$3$0.t0);\n              throw context$3$0.t0;\n\n            case 19:\n              return context$3$0.abrupt('return', result);\n\n            case 20:\n            case 'end':\n              return context$3$0.stop();\n          }\n        }, callee$2$0, this, [[9, 15]]);\n      }).bind(this));\n    }\n  }]);\n\n  return Basic;\n})(Transport);\n\nexports.Basic = Basic;\n\nvar OAuth2 = (function (_Transport2) {\n  _inherits(OAuth2, _Transport2);\n\n  function OAuth2(credentials) {\n    _classCallCheck(this, OAuth2);\n\n    _get(Object.getPrototypeOf(OAuth2.prototype), 'constructor', this).call(this, credentials);\n  }\n\n  /**\n   * @return {Promise} promise that will resolve with access token.\n   */\n\n  _createClass(OAuth2, [{\n    key: 'send',\n    value: function send(request, url) {\n      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n      return (0, _co2['default'])(regeneratorRuntime.mark(function callee$2$0() {\n        var sandbox, transformRequest, transformResponse, onerror, result, xhr, token;\n        return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {\n          while (1) switch (context$3$0.prev = context$3$0.next) {\n            case 0:\n              sandbox = options.sandbox;\n              transformRequest = request.transformRequest;\n              transformResponse = request.transformResponse;\n              onerror = request.onerror;\n\n              if (!('retry' in options)) options.retry = true;\n\n              result = undefined, xhr = undefined;\n              context$3$0.prev = 6;\n              context$3$0.next = 9;\n              return access(this.credentials, options);\n\n            case 9:\n              token = context$3$0.sent;\n\n              xhr = new _xmlhttprequest2['default']();\n              if (sandbox) sandbox.add(xhr);\n              xhr.open(request.method, url, true /* async */);\n              xhr.setRequestHeader('Authorization', 'Bearer ' + token);\n              if (transformRequest) transformRequest(xhr);\n              context$3$0.next = 17;\n              return xhr.send(request.requestData);\n\n            case 17:\n              result = transformResponse ? transformResponse(xhr) : xhr;\n              context$3$0.next = 28;\n              break;\n\n            case 20:\n              context$3$0.prev = 20;\n              context$3$0.t0 = context$3$0['catch'](6);\n\n              if (!(options.retry && xhr.status === 401)) {\n                context$3$0.next = 26;\n                break;\n              }\n\n              // Force expiration.\n              this.credentials.expiration = 0;\n              // Retry once at most.\n              options.retry = false;\n              return context$3$0.abrupt('return', this.send(request, url, options));\n\n            case 26:\n\n              if (onerror) onerror(context$3$0.t0);\n              throw context$3$0.t0;\n\n            case 28:\n              return context$3$0.abrupt('return', result);\n\n            case 29:\n            case 'end':\n              return context$3$0.stop();\n          }\n        }, callee$2$0, this, [[6, 20]]);\n      }).bind(this));\n    }\n  }]);\n\n  return OAuth2;\n})(Transport);\n\nexports.OAuth2 = OAuth2;\nfunction access(credentials, options) {\n  if (!credentials.accessToken) {\n    return getAccessToken(credentials, options);\n  }\n\n  if (credentials.refreshToken && isExpired(credentials)) {\n    return refreshAccessToken(credentials, options);\n  }\n\n  return Promise.resolve(credentials.accessToken);\n}\n\nfunction isExpired(credentials) {\n  return typeof credentials.expiration === 'number' && Date.now() > credentials.expiration;\n}\n\nvar getAccessToken = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(credentials, options) {\n  var sandbox, xhr, data, now, response;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        sandbox = options.sandbox;\n        xhr = new _xmlhttprequest2['default']();\n\n        if (sandbox) sandbox.add(xhr);\n        xhr.open('POST', credentials.tokenUrl, true /* async */);\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\n        data = _querystring2['default'].stringify({\n          code: credentials.authorizationCode,\n          redirect_uri: credentials.redirectUrl,\n          client_id: credentials.clientId,\n          client_secret: credentials.clientSecret,\n          grant_type: 'authorization_code'\n        });\n        now = Date.now();\n        context$1$0.next = 9;\n        return xhr.send(data);\n\n      case 9:\n        response = JSON.parse(xhr.responseText);\n\n        credentials.accessToken = response.access_token;\n        credentials.refreshToken = 'refresh_token' in response ? response.refresh_token : null;\n        credentials.expiration = 'expires_in' in response ? now + response.expires_in : null;\n\n        return context$1$0.abrupt('return', response.access_token);\n\n      case 14:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\nvar refreshAccessToken = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(credentials, options) {\n  var sandbox, xhr, data, now, response;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        sandbox = options.sandbox;\n        xhr = new _xmlhttprequest2['default']();\n\n        if (sandbox) sandbox.add(xhr);\n        xhr.open('POST', credentials.tokenUrl, true /* async */);\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\n        data = _querystring2['default'].stringify({\n          client_id: credentials.clientId,\n          client_secret: credentials.clientSecret,\n          refresh_token: credentials.refreshToken,\n          grant_type: 'refresh_token'\n        });\n        now = Date.now();\n        context$1$0.next = 9;\n        return xhr.send(data);\n\n      case 9:\n        response = JSON.parse(xhr.responseText);\n\n        credentials.accessToken = response.access_token;\n        credentials.expiration = 'expires_in' in response ? now + response.expires_in : null;\n\n        return context$1$0.abrupt('return', response.access_token);\n\n      case 13:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n},{\"./xmlhttprequest\":23,\"co\":29,\"querystring\":27}],22:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createObject = createObject;\nexports.updateObject = updateObject;\nexports.deleteObject = deleteObject;\nexports.syncCollection = syncCollection;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _co = require('co');\n\nvar _co2 = _interopRequireDefault(_co);\n\nvar _fuzzy_url_equals = require('./fuzzy_url_equals');\n\nvar _fuzzy_url_equals2 = _interopRequireDefault(_fuzzy_url_equals);\n\nvar _namespace = require('./namespace');\n\nvar ns = _interopRequireWildcard(_namespace);\n\nvar _request = require('./request');\n\nvar request = _interopRequireWildcard(_request);\n\nvar debug = require('./debug')('dav:webdav');\n\n/**\n * @param {String} objectUrl url for webdav object.\n * @param {String} objectData webdav object data.\n */\n\nfunction createObject(objectUrl, objectData, options) {\n  var req = request.basic({ method: 'PUT', data: objectData });\n  return options.xhr.send(req, objectUrl, { sandbox: options.sandbox });\n}\n\nfunction updateObject(objectUrl, objectData, etag, options) {\n  var req = request.basic({ method: 'PUT', data: objectData, etag: etag });\n  return options.xhr.send(req, objectUrl, { sandbox: options.sandbox });\n}\n\nfunction deleteObject(objectUrl, etag, options) {\n  var req = request.basic({ method: 'DELETE', etag: etag });\n  return options.xhr.send(req, objectUrl, { sandbox: options.sandbox });\n}\n\nfunction syncCollection(collection, options) {\n  var syncMethod = undefined;\n  if ('syncMethod' in options) {\n    syncMethod = options.syncMethod;\n  } else if (collection.reports && collection.reports.indexOf('syncCollection') !== -1) {\n    syncMethod = 'webdav';\n  } else {\n    syncMethod = 'basic';\n  }\n\n  if (syncMethod === 'webdav') {\n    debug('rfc 6578 sync.');\n    return options.webdavSync(collection, options);\n  } else {\n    debug('basic sync.');\n    return options.basicSync(collection, options);\n  }\n}\n\n/**\n * @param {dav.DAVCollection} collection to fetch report set for.\n */\nvar supportedReportSet = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(collection, options) {\n  var req, response;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        debug('Checking supported report set for collection at ' + collection.url);\n        req = request.propfind({\n          props: [{ name: 'supported-report-set', namespace: ns.DAV }],\n          depth: 1,\n          mergeResponses: true\n        });\n        context$1$0.next = 4;\n        return options.xhr.send(req, collection.url, {\n          sandbox: options.sandbox\n        });\n\n      case 4:\n        response = context$1$0.sent;\n        return context$1$0.abrupt('return', response.props.supportedReportSet);\n\n      case 6:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\n\nexports.supportedReportSet = supportedReportSet;\nvar isCollectionDirty = _co2['default'].wrap(regeneratorRuntime.mark(function callee$0$0(collection, options) {\n  var req, responses, response;\n  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {\n    while (1) switch (context$1$0.prev = context$1$0.next) {\n      case 0:\n        if (collection.ctag) {\n          context$1$0.next = 3;\n          break;\n        }\n\n        debug('Missing ctag.');\n        return context$1$0.abrupt('return', false);\n\n      case 3:\n\n        debug('Fetch remote getctag prop.');\n        req = request.propfind({\n          props: [{ name: 'getctag', namespace: ns.CALENDAR_SERVER }],\n          depth: 0\n        });\n        context$1$0.next = 7;\n        return options.xhr.send(req, collection.account.homeUrl, {\n          sandbox: options.sandbox\n        });\n\n      case 7:\n        responses = context$1$0.sent;\n        response = responses.filter(function (response) {\n          // Find the response that corresponds to the parameter collection.\n          return (0, _fuzzy_url_equals2['default'])(collection.url, response.href);\n        })[0];\n\n        if (response) {\n          context$1$0.next = 11;\n          break;\n        }\n\n        throw new Error('Could not find collection on remote. Was it deleted?');\n\n      case 11:\n\n        debug('Check whether cached ctag matches remote.');\n        return context$1$0.abrupt('return', collection.ctag !== response.props.getctag);\n\n      case 13:\n      case 'end':\n        return context$1$0.stop();\n    }\n  }, callee$0$0, this);\n}));\nexports.isCollectionDirty = isCollectionDirty;\n},{\"./debug\":6,\"./fuzzy_url_equals\":7,\"./namespace\":10,\"./request\":12,\"co\":29}],23:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar debug = require('./debug')('dav:xmlhttprequest');\n\nvar Native = undefined;\nif (typeof self !== 'undefined' && 'XMLHttpRequest' in self) {\n  Native = self.XMLHttpRequest;\n} else {\n  // Trick browserify into not loading XMLHttpRequest polyfill\n  // since it is available in the platform (including web workers)\n  Native = require(false || 'xmlhttprequest').XMLHttpRequest;\n}\n\n/**\n * @fileoverview Promise wrapper around native xhr api.\n */\n\nvar XMLHttpRequest = (function () {\n  function XMLHttpRequest(options) {\n    var _this = this;\n\n    _classCallCheck(this, XMLHttpRequest);\n\n    this.request = new Native(options);\n    this.sandbox = null;\n\n    /* readwrite */\n    ['response', 'responseText', 'responseType', 'responseXML', 'timeout', 'upload', 'withCredentials'].forEach(function (attribute) {\n      Object.defineProperty(_this, attribute, {\n        get: function get() {\n          return this.request[attribute];\n        },\n        set: function set(value) {\n          this.request[attribute] = value;\n        }\n      });\n    });\n\n    /* readonly */\n    ['status', 'statusText'].forEach(function (attribute) {\n      Object.defineProperty(_this, attribute, {\n        get: function get() {\n          return this.request[attribute];\n        }\n      });\n    });\n  }\n\n  _createClass(XMLHttpRequest, [{\n    key: 'abort',\n    value: function abort() {\n      return this._callNative('abort', arguments);\n    }\n  }, {\n    key: 'getAllResponseHeaders',\n    value: function getAllResponseHeaders() {\n      return this._callNative('getAllResponseHeaders', arguments);\n    }\n  }, {\n    key: 'getResponseHeader',\n    value: function getResponseHeader() {\n      return this._callNative('getResponseHeader', arguments);\n    }\n  }, {\n    key: 'open',\n    value: function open() {\n      return this._callNative('open', arguments);\n    }\n  }, {\n    key: 'overrideMimeType',\n    value: function overrideMimeType() {\n      return this._callNative('overrideMimeType', arguments);\n    }\n  }, {\n    key: 'setRequestHeader',\n    value: function setRequestHeader() {\n      return this._callNative('setRequestHeader', arguments);\n    }\n  }, {\n    key: 'send',\n    value: function send(data) {\n      debug('Sending request data: ' + data);\n      if (this.sandbox) this.sandbox.add(this);\n      var request = this.request;\n      request.send(data);\n      return new Promise(function (resolve, reject) {\n        request.onreadystatechange = function () {\n          if (request.readyState !== 4 /* done */) {\n              return;\n            }\n\n          if (request.status < 200 || request.status >= 400) {\n            return reject(new Error('Bad status: ' + request.status));\n          }\n\n          return resolve(request.responseText);\n        };\n\n        request.ontimeout = function () {\n          reject(new Error('Request timed out after ' + request.timeout + ' ms'));\n        };\n      });\n    }\n  }, {\n    key: '_callNative',\n    value: function _callNative(method, args) {\n      return this.request[method].apply(this.request, args);\n    }\n  }]);\n\n  return XMLHttpRequest;\n})();\n\nexports['default'] = XMLHttpRequest;\nmodule.exports = exports['default'];\n},{\"./debug\":6}],24:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],25:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n},{}],26:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n},{}],27:[function(require,module,exports){\n'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n},{\"./decode\":25,\"./encode\":26}],28:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar punycode = require('punycode');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a puny coded representation of \"domain\".\n      // It only converts the part of the domain name that\n      // has non ASCII characters. I.e. it dosent matter if\n      // you call it with a domain that already is in ASCII.\n      var domainArray = this.hostname.split('.');\n      var newOut = [];\n      for (var i = 0; i < domainArray.length; ++i) {\n        var s = domainArray[i];\n        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?\n            'xn--' + punycode.encode(s) : s);\n      }\n      this.hostname = newOut.join('.');\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  Object.keys(this).forEach(function(k) {\n    result[k] = this[k];\n  }, this);\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    Object.keys(relative).forEach(function(k) {\n      if (k !== 'protocol')\n        result[k] = relative[k];\n    });\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      Object.keys(relative).forEach(function(k) {\n        result[k] = relative[k];\n      });\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especialy happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!isNull(result.pathname) || !isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host) && (last === '.' || last === '..') ||\n      last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last == '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especialy happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!isNull(result.pathname) || !isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\nfunction isString(arg) {\n  return typeof arg === \"string\";\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isNull(arg) {\n  return arg === null;\n}\nfunction isNullOrUndefined(arg) {\n  return  arg == null;\n}\n\n},{\"punycode\":24,\"querystring\":27}],29:[function(require,module,exports){\n\n/**\n * slice() reference.\n */\n\nvar slice = Array.prototype.slice;\n\n/**\n * Expose `co`.\n */\n\nmodule.exports = co['default'] = co.co = co;\n\n/**\n * Wrap the given generator `fn` into a\n * function that returns a promise.\n * This is a separate function so that\n * every `co()` call doesn't create a new,\n * unnecessary closure.\n *\n * @param {GeneratorFunction} fn\n * @return {Function}\n * @api public\n */\n\nco.wrap = function (fn) {\n  createPromise.__generatorFunction__ = fn;\n  return createPromise;\n  function createPromise() {\n    return co.call(this, fn.apply(this, arguments));\n  }\n};\n\n/**\n * Execute the generator function or a generator\n * and return a promise.\n *\n * @param {Function} fn\n * @return {Promise}\n * @api public\n */\n\nfunction co(gen) {\n  var ctx = this;\n  var args = slice.call(arguments, 1)\n\n  // we wrap everything in a promise to avoid promise chaining,\n  // which leads to memory leak errors.\n  // see https://github.com/tj/co/issues/180\n  return new Promise(function(resolve, reject) {\n    if (typeof gen === 'function') gen = gen.apply(ctx, args);\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\n\n    onFulfilled();\n\n    /**\n     * @param {Mixed} res\n     * @return {Promise}\n     * @api private\n     */\n\n    function onFulfilled(res) {\n      var ret;\n      try {\n        ret = gen.next(res);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    /**\n     * @param {Error} err\n     * @return {Promise}\n     * @api private\n     */\n\n    function onRejected(err) {\n      var ret;\n      try {\n        ret = gen.throw(err);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    /**\n     * Get the next value in the generator,\n     * return a promise.\n     *\n     * @param {Object} ret\n     * @return {Promise}\n     * @api private\n     */\n\n    function next(ret) {\n      if (ret.done) return resolve(ret.value);\n      var value = toPromise.call(ctx, ret.value);\n      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);\n      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\n        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\n    }\n  });\n}\n\n/**\n * Convert a `yield`ed value into a promise.\n *\n * @param {Mixed} obj\n * @return {Promise}\n * @api private\n */\n\nfunction toPromise(obj) {\n  if (!obj) return obj;\n  if (isPromise(obj)) return obj;\n  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);\n  if ('function' == typeof obj) return thunkToPromise.call(this, obj);\n  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);\n  if (isObject(obj)) return objectToPromise.call(this, obj);\n  return obj;\n}\n\n/**\n * Convert a thunk to a promise.\n *\n * @param {Function}\n * @return {Promise}\n * @api private\n */\n\nfunction thunkToPromise(fn) {\n  var ctx = this;\n  return new Promise(function (resolve, reject) {\n    fn.call(ctx, function (err, res) {\n      if (err) return reject(err);\n      if (arguments.length > 2) res = slice.call(arguments, 1);\n      resolve(res);\n    });\n  });\n}\n\n/**\n * Convert an array of \"yieldables\" to a promise.\n * Uses `Promise.all()` internally.\n *\n * @param {Array} obj\n * @return {Promise}\n * @api private\n */\n\nfunction arrayToPromise(obj) {\n  return Promise.all(obj.map(toPromise, this));\n}\n\n/**\n * Convert an object of \"yieldables\" to a promise.\n * Uses `Promise.all()` internally.\n *\n * @param {Object} obj\n * @return {Promise}\n * @api private\n */\n\nfunction objectToPromise(obj){\n  var results = new obj.constructor();\n  var keys = Object.keys(obj);\n  var promises = [];\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var promise = toPromise.call(this, obj[key]);\n    if (promise && isPromise(promise)) defer(promise, key);\n    else results[key] = obj[key];\n  }\n  return Promise.all(promises).then(function () {\n    return results;\n  });\n\n  function defer(promise, key) {\n    // predefine the key in the result\n    results[key] = undefined;\n    promises.push(promise.then(function (res) {\n      results[key] = res;\n    }));\n  }\n}\n\n/**\n * Check if `obj` is a promise.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isPromise(obj) {\n  return 'function' == typeof obj.then;\n}\n\n/**\n * Check if `obj` is a generator.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isGenerator(obj) {\n  return 'function' == typeof obj.next && 'function' == typeof obj.throw;\n}\n\n/**\n * Check if `obj` is a generator function.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\nfunction isGeneratorFunction(obj) {\n  var constructor = obj.constructor;\n  if (!constructor) return false;\n  if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;\n  return isGenerator(constructor.prototype);\n}\n\n/**\n * Check for plain object.\n *\n * @param {Mixed} val\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(val) {\n  return Object == val.constructor;\n}\n\n},{}],30:[function(require,module,exports){\nfunction DOMParser(options){\r\n\tthis.options = options ||{locator:{}};\r\n\t\r\n}\r\nDOMParser.prototype.parseFromString = function(source,mimeType){\t\r\n\tvar options = this.options;\r\n\tvar sax =  new XMLReader();\r\n\tvar domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler\r\n\tvar errorHandler = options.errorHandler;\r\n\tvar locator = options.locator;\r\n\tvar defaultNSMap = options.xmlns||{};\r\n\tvar entityMap = {'lt':'<','gt':'>','amp':'&','quot':'\"','apos':\"'\"}\r\n\tif(locator){\r\n\t\tdomBuilder.setDocumentLocator(locator)\r\n\t}\r\n\t\r\n\tsax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);\r\n\tsax.domBuilder = options.domBuilder || domBuilder;\r\n\tif(/\\/x?html?$/.test(mimeType)){\r\n\t\tentityMap.nbsp = '\\xa0';\r\n\t\tentityMap.copy = '\\xa9';\r\n\t\tdefaultNSMap['']= 'http://www.w3.org/1999/xhtml';\r\n\t}\r\n\tif(source){\r\n\t\tsax.parse(source,defaultNSMap,entityMap);\r\n\t}else{\r\n\t\tsax.errorHandler.error(\"invalid document source\");\r\n\t}\r\n\treturn domBuilder.document;\r\n}\r\nfunction buildErrorHandler(errorImpl,domBuilder,locator){\r\n\tif(!errorImpl){\r\n\t\tif(domBuilder instanceof DOMHandler){\r\n\t\t\treturn domBuilder;\r\n\t\t}\r\n\t\terrorImpl = domBuilder ;\r\n\t}\r\n\tvar errorHandler = {}\r\n\tvar isCallback = errorImpl instanceof Function;\r\n\tlocator = locator||{}\r\n\tfunction build(key){\r\n\t\tvar fn = errorImpl[key];\r\n\t\tif(!fn){\r\n\t\t\tif(isCallback){\r\n\t\t\t\tfn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;\r\n\t\t\t}else{\r\n\t\t\t\tvar i=arguments.length;\r\n\t\t\t\twhile(--i){\r\n\t\t\t\t\tif(fn = errorImpl[arguments[i]]){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\terrorHandler[key] = fn && function(msg){\r\n\t\t\tfn(msg+_locator(locator));\r\n\t\t}||function(){};\r\n\t}\r\n\tbuild('warning','warn');\r\n\tbuild('error','warn','warning');\r\n\tbuild('fatalError','warn','warning','error');\r\n\treturn errorHandler;\r\n}\r\n/**\r\n * +ContentHandler+ErrorHandler\r\n * +LexicalHandler+EntityResolver2\r\n * -DeclHandler-DTDHandler \r\n * \r\n * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler\r\n * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html\r\n */\r\nfunction DOMHandler() {\r\n    this.cdata = false;\r\n}\r\nfunction position(locator,node){\r\n\tnode.lineNumber = locator.lineNumber;\r\n\tnode.columnNumber = locator.columnNumber;\r\n}\r\n/**\r\n * @see org.xml.sax.ContentHandler#startDocument\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html\r\n */ \r\nDOMHandler.prototype = {\r\n\tstartDocument : function() {\r\n    \tthis.document = new DOMImplementation().createDocument(null, null, null);\r\n    \tif (this.locator) {\r\n        \tthis.document.documentURI = this.locator.systemId;\r\n    \t}\r\n\t},\r\n\tstartElement:function(namespaceURI, localName, qName, attrs) {\r\n\t\tvar doc = this.document;\r\n\t    var el = doc.createElementNS(namespaceURI, qName||localName);\r\n\t    var len = attrs.length;\r\n\t    appendElement(this, el);\r\n\t    this.currentElement = el;\r\n\t    \r\n\t\tthis.locator && position(this.locator,el)\r\n\t    for (var i = 0 ; i < len; i++) {\r\n\t        var namespaceURI = attrs.getURI(i);\r\n\t        var value = attrs.getValue(i);\r\n\t        var qName = attrs.getQName(i);\r\n\t\t\tvar attr = doc.createAttributeNS(namespaceURI, qName);\r\n\t\t\tif( attr.getOffset){\r\n\t\t\t\tposition(attr.getOffset(1),attr)\r\n\t\t\t}\r\n\t\t\tattr.value = attr.nodeValue = value;\r\n\t\t\tel.setAttributeNode(attr)\r\n\t    }\r\n\t},\r\n\tendElement:function(namespaceURI, localName, qName) {\r\n\t\tvar current = this.currentElement\r\n\t    var tagName = current.tagName;\r\n\t    this.currentElement = current.parentNode;\r\n\t},\r\n\tstartPrefixMapping:function(prefix, uri) {\r\n\t},\r\n\tendPrefixMapping:function(prefix) {\r\n\t},\r\n\tprocessingInstruction:function(target, data) {\r\n\t    var ins = this.document.createProcessingInstruction(target, data);\r\n\t    this.locator && position(this.locator,ins)\r\n\t    appendElement(this, ins);\r\n\t},\r\n\tignorableWhitespace:function(ch, start, length) {\r\n\t},\r\n\tcharacters:function(chars, start, length) {\r\n\t\tchars = _toString.apply(this,arguments)\r\n\t\t//console.log(chars)\r\n\t\tif(this.currentElement && chars){\r\n\t\t\tif (this.cdata) {\r\n\t\t\t\tvar charNode = this.document.createCDATASection(chars);\r\n\t\t\t\tthis.currentElement.appendChild(charNode);\r\n\t\t\t} else {\r\n\t\t\t\tvar charNode = this.document.createTextNode(chars);\r\n\t\t\t\tthis.currentElement.appendChild(charNode);\r\n\t\t\t}\r\n\t\t\tthis.locator && position(this.locator,charNode)\r\n\t\t}\r\n\t},\r\n\tskippedEntity:function(name) {\r\n\t},\r\n\tendDocument:function() {\r\n\t\tthis.document.normalize();\r\n\t},\r\n\tsetDocumentLocator:function (locator) {\r\n\t    if(this.locator = locator){// && !('lineNumber' in locator)){\r\n\t    \tlocator.lineNumber = 0;\r\n\t    }\r\n\t},\r\n\t//LexicalHandler\r\n\tcomment:function(chars, start, length) {\r\n\t\tchars = _toString.apply(this,arguments)\r\n\t    var comm = this.document.createComment(chars);\r\n\t    this.locator && position(this.locator,comm)\r\n\t    appendElement(this, comm);\r\n\t},\r\n\t\r\n\tstartCDATA:function() {\r\n\t    //used in characters() methods\r\n\t    this.cdata = true;\r\n\t},\r\n\tendCDATA:function() {\r\n\t    this.cdata = false;\r\n\t},\r\n\t\r\n\tstartDTD:function(name, publicId, systemId) {\r\n\t\tvar impl = this.document.implementation;\r\n\t    if (impl && impl.createDocumentType) {\r\n\t        var dt = impl.createDocumentType(name, publicId, systemId);\r\n\t        this.locator && position(this.locator,dt)\r\n\t        appendElement(this, dt);\r\n\t    }\r\n\t},\r\n\t/**\r\n\t * @see org.xml.sax.ErrorHandler\r\n\t * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\r\n\t */\r\n\twarning:function(error) {\r\n\t\tconsole.warn(error,_locator(this.locator));\r\n\t},\r\n\terror:function(error) {\r\n\t\tconsole.error(error,_locator(this.locator));\r\n\t},\r\n\tfatalError:function(error) {\r\n\t\tconsole.error(error,_locator(this.locator));\r\n\t    throw error;\r\n\t}\r\n}\r\nfunction _locator(l){\r\n\tif(l){\r\n\t\treturn '\\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'\r\n\t}\r\n}\r\nfunction _toString(chars,start,length){\r\n\tif(typeof chars == 'string'){\r\n\t\treturn chars.substr(start,length)\r\n\t}else{//java sax connect width xmldom on rhino(what about: \"? && !(chars instanceof String)\")\r\n\t\tif(chars.length >= start+length || start){\r\n\t\t\treturn new java.lang.String(chars,start,length)+'';\r\n\t\t}\r\n\t\treturn chars;\r\n\t}\r\n}\r\n\r\n/*\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html\r\n * used method of org.xml.sax.ext.LexicalHandler:\r\n *  #comment(chars, start, length)\r\n *  #startCDATA()\r\n *  #endCDATA()\r\n *  #startDTD(name, publicId, systemId)\r\n *\r\n *\r\n * IGNORED method of org.xml.sax.ext.LexicalHandler:\r\n *  #endDTD()\r\n *  #startEntity(name)\r\n *  #endEntity(name)\r\n *\r\n *\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html\r\n * IGNORED method of org.xml.sax.ext.DeclHandler\r\n * \t#attributeDecl(eName, aName, type, mode, value)\r\n *  #elementDecl(name, model)\r\n *  #externalEntityDecl(name, publicId, systemId)\r\n *  #internalEntityDecl(name, value)\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html\r\n * IGNORED method of org.xml.sax.EntityResolver2\r\n *  #resolveEntity(String name,String publicId,String baseURI,String systemId)\r\n *  #resolveEntity(publicId, systemId)\r\n *  #getExternalSubset(name, baseURI)\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html\r\n * IGNORED method of org.xml.sax.DTDHandler\r\n *  #notationDecl(name, publicId, systemId) {};\r\n *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};\r\n */\r\n\"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl\".replace(/\\w+/g,function(key){\r\n\tDOMHandler.prototype[key] = function(){return null}\r\n})\r\n\r\n/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */\r\nfunction appendElement (hander,node) {\r\n    if (!hander.currentElement) {\r\n        hander.document.appendChild(node);\r\n    } else {\r\n        hander.currentElement.appendChild(node);\r\n    }\r\n}//appendChild and setAttributeNS are preformance key\r\n\r\nif(typeof require == 'function'){\r\n\tvar XMLReader = require('./sax').XMLReader;\r\n\tvar DOMImplementation = exports.DOMImplementation = require('./dom').DOMImplementation;\r\n\texports.XMLSerializer = require('./dom').XMLSerializer ;\r\n\texports.DOMParser = DOMParser;\r\n}\r\n\n},{\"./dom\":31,\"./sax\":32}],31:[function(require,module,exports){\n/*\n * DOM Level 2\n * Object DOMException\n * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html\n */\n\nfunction copy(src,dest){\n\tfor(var p in src){\n\t\tdest[p] = src[p];\n\t}\n}\n/**\n^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*((?:.*\\{\\s*?[\\r\\n][\\s\\S]*?^})|\\S.*?(?=[;\\r\\n]));?\n^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*(\\S.*?(?=[;\\r\\n]));?\n */\nfunction _extends(Class,Super){\n\tvar pt = Class.prototype;\n\tif(Object.create){\n\t\tvar ppt = Object.create(Super.prototype)\n\t\tpt.__proto__ = ppt;\n\t}\n\tif(!(pt instanceof Super)){\n\t\tfunction t(){};\n\t\tt.prototype = Super.prototype;\n\t\tt = new t();\n\t\tcopy(pt,t);\n\t\tClass.prototype = pt = t;\n\t}\n\tif(pt.constructor != Class){\n\t\tif(typeof Class != 'function'){\n\t\t\tconsole.error(\"unknow Class:\"+Class)\n\t\t}\n\t\tpt.constructor = Class\n\t}\n}\nvar htmlns = 'http://www.w3.org/1999/xhtml' ;\n// Node Types\nvar NodeType = {}\nvar ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;\nvar ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;\nvar TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;\nvar CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;\nvar ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;\nvar ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;\nvar PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;\nvar COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;\nvar DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;\nvar DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;\nvar DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;\nvar NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;\n\n// ExceptionCode\nvar ExceptionCode = {}\nvar ExceptionMessage = {};\nvar INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]=\"Index size error\"),1);\nvar DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]=\"DOMString size error\"),2);\nvar HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]=\"Hierarchy request error\"),3);\nvar WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]=\"Wrong document\"),4);\nvar INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]=\"Invalid character\"),5);\nvar NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]=\"No data allowed\"),6);\nvar NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]=\"No modification allowed\"),7);\nvar NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]=\"Not found\"),8);\nvar NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]=\"Not supported\"),9);\nvar INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]=\"Attribute in use\"),10);\n//level2\nvar INVALID_STATE_ERR        \t= ExceptionCode.INVALID_STATE_ERR        \t= ((ExceptionMessage[11]=\"Invalid state\"),11);\nvar SYNTAX_ERR               \t= ExceptionCode.SYNTAX_ERR               \t= ((ExceptionMessage[12]=\"Syntax error\"),12);\nvar INVALID_MODIFICATION_ERR \t= ExceptionCode.INVALID_MODIFICATION_ERR \t= ((ExceptionMessage[13]=\"Invalid modification\"),13);\nvar NAMESPACE_ERR            \t= ExceptionCode.NAMESPACE_ERR           \t= ((ExceptionMessage[14]=\"Invalid namespace\"),14);\nvar INVALID_ACCESS_ERR       \t= ExceptionCode.INVALID_ACCESS_ERR      \t= ((ExceptionMessage[15]=\"Invalid access\"),15);\n\n\nfunction DOMException(code, message) {\n\tif(message instanceof Error){\n\t\tvar error = message;\n\t}else{\n\t\terror = this;\n\t\tError.call(this, ExceptionMessage[code]);\n\t\tthis.message = ExceptionMessage[code];\n\t\tif(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);\n\t}\n\terror.code = code;\n\tif(message) this.message = this.message + \": \" + message;\n\treturn error;\n};\nDOMException.prototype = Error.prototype;\ncopy(ExceptionCode,DOMException)\n/**\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177\n * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.\n * The items in the NodeList are accessible via an integral index, starting from 0.\n */\nfunction NodeList() {\n};\nNodeList.prototype = {\n\t/**\n\t * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.\n\t * @standard level1\n\t */\n\tlength:0, \n\t/**\n\t * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.\n\t * @standard level1\n\t * @param index  unsigned long \n\t *   Index into the collection.\n\t * @return Node\n\t * \tThe node at the indexth position in the NodeList, or null if that is not a valid index. \n\t */\n\titem: function(index) {\n\t\treturn this[index] || null;\n\t}\n};\nfunction LiveNodeList(node,refresh){\n\tthis._node = node;\n\tthis._refresh = refresh\n\t_updateLiveList(this);\n}\nfunction _updateLiveList(list){\n\tvar inc = list._node._inc || list._node.ownerDocument._inc;\n\tif(list._inc != inc){\n\t\tvar ls = list._refresh(list._node);\n\t\t//console.log(ls.length)\n\t\t__set__(list,'length',ls.length);\n\t\tcopy(ls,list);\n\t\tlist._inc = inc;\n\t}\n}\nLiveNodeList.prototype.item = function(i){\n\t_updateLiveList(this);\n\treturn this[i];\n}\n\n_extends(LiveNodeList,NodeList);\n/**\n * \n * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.\n * NamedNodeMap objects in the DOM are live.\n * used for attributes or DocumentType entities \n */\nfunction NamedNodeMap() {\n};\n\nfunction _findNodeIndex(list,node){\n\tvar i = list.length;\n\twhile(i--){\n\t\tif(list[i] === node){return i}\n\t}\n}\n\nfunction _addNamedNode(el,list,newAttr,oldAttr){\n\tif(oldAttr){\n\t\tlist[_findNodeIndex(list,oldAttr)] = newAttr;\n\t}else{\n\t\tlist[list.length++] = newAttr;\n\t}\n\tif(el){\n\t\tnewAttr.ownerElement = el;\n\t\tvar doc = el.ownerDocument;\n\t\tif(doc){\n\t\t\toldAttr && _onRemoveAttribute(doc,el,oldAttr);\n\t\t\t_onAddAttribute(doc,el,newAttr);\n\t\t}\n\t}\n}\nfunction _removeNamedNode(el,list,attr){\n\tvar i = _findNodeIndex(list,attr);\n\tif(i>=0){\n\t\tvar lastIndex = list.length-1\n\t\twhile(i<lastIndex){\n\t\t\tlist[i] = list[++i]\n\t\t}\n\t\tlist.length = lastIndex;\n\t\tif(el){\n\t\t\tvar doc = el.ownerDocument;\n\t\t\tif(doc){\n\t\t\t\t_onRemoveAttribute(doc,el,attr);\n\t\t\t\tattr.ownerElement = null;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tthrow DOMException(NOT_FOUND_ERR,new Error())\n\t}\n}\nNamedNodeMap.prototype = {\n\tlength:0,\n\titem:NodeList.prototype.item,\n\tgetNamedItem: function(key) {\n//\t\tif(key.indexOf(':')>0 || key == 'xmlns'){\n//\t\t\treturn null;\n//\t\t}\n\t\tvar i = this.length;\n\t\twhile(i--){\n\t\t\tvar attr = this[i];\n\t\t\tif(attr.nodeName == key){\n\t\t\t\treturn attr;\n\t\t\t}\n\t\t}\n\t},\n\tsetNamedItem: function(attr) {\n\t\tvar el = attr.ownerElement;\n\t\tif(el && el!=this._ownerElement){\n\t\t\tthrow new DOMException(INUSE_ATTRIBUTE_ERR);\n\t\t}\n\t\tvar oldAttr = this.getNamedItem(attr.nodeName);\n\t\t_addNamedNode(this._ownerElement,this,attr,oldAttr);\n\t\treturn oldAttr;\n\t},\n\t/* returns Node */\n\tsetNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR\n\t\tvar el = attr.ownerElement, oldAttr;\n\t\tif(el && el!=this._ownerElement){\n\t\t\tthrow new DOMException(INUSE_ATTRIBUTE_ERR);\n\t\t}\n\t\toldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);\n\t\t_addNamedNode(this._ownerElement,this,attr,oldAttr);\n\t\treturn oldAttr;\n\t},\n\n\t/* returns Node */\n\tremoveNamedItem: function(key) {\n\t\tvar attr = this.getNamedItem(key);\n\t\t_removeNamedNode(this._ownerElement,this,attr);\n\t\treturn attr;\n\t\t\n\t\t\n\t},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR\n\t\n\t//for level2\n\tremoveNamedItemNS:function(namespaceURI,localName){\n\t\tvar attr = this.getNamedItemNS(namespaceURI,localName);\n\t\t_removeNamedNode(this._ownerElement,this,attr);\n\t\treturn attr;\n\t},\n\tgetNamedItemNS: function(namespaceURI, localName) {\n\t\tvar i = this.length;\n\t\twhile(i--){\n\t\t\tvar node = this[i];\n\t\t\tif(node.localName == localName && node.namespaceURI == namespaceURI){\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n};\n/**\n * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490\n */\nfunction DOMImplementation(/* Object */ features) {\n\tthis._features = {};\n\tif (features) {\n\t\tfor (var feature in features) {\n\t\t\t this._features = features[feature];\n\t\t}\n\t}\n};\n\nDOMImplementation.prototype = {\n\thasFeature: function(/* string */ feature, /* string */ version) {\n\t\tvar versions = this._features[feature.toLowerCase()];\n\t\tif (versions && (!version || version in versions)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t},\n\t// Introduced in DOM Level 2:\n\tcreateDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR\n\t\tvar doc = new Document();\n\t\tdoc.doctype = doctype;\n\t\tif(doctype){\n\t\t\tdoc.appendChild(doctype);\n\t\t}\n\t\tdoc.implementation = this;\n\t\tdoc.childNodes = new NodeList();\n\t\tif(qualifiedName){\n\t\t\tvar root = doc.createElementNS(namespaceURI,qualifiedName);\n\t\t\tdoc.appendChild(root);\n\t\t}\n\t\treturn doc;\n\t},\n\t// Introduced in DOM Level 2:\n\tcreateDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR\n\t\tvar node = new DocumentType();\n\t\tnode.name = qualifiedName;\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.publicId = publicId;\n\t\tnode.systemId = systemId;\n\t\t// Introduced in DOM Level 2:\n\t\t//readonly attribute DOMString        internalSubset;\n\t\t\n\t\t//TODO:..\n\t\t//  readonly attribute NamedNodeMap     entities;\n\t\t//  readonly attribute NamedNodeMap     notations;\n\t\treturn node;\n\t}\n};\n\n\n/**\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247\n */\n\nfunction Node() {\n};\n\nNode.prototype = {\n\tfirstChild : null,\n\tlastChild : null,\n\tpreviousSibling : null,\n\tnextSibling : null,\n\tattributes : null,\n\tparentNode : null,\n\tchildNodes : null,\n\townerDocument : null,\n\tnodeValue : null,\n\tnamespaceURI : null,\n\tprefix : null,\n\tlocalName : null,\n\t// Modified in DOM Level 2:\n\tinsertBefore:function(newChild, refChild){//raises \n\t\treturn _insertBefore(this,newChild,refChild);\n\t},\n\treplaceChild:function(newChild, oldChild){//raises \n\t\tthis.insertBefore(newChild,oldChild);\n\t\tif(oldChild){\n\t\t\tthis.removeChild(oldChild);\n\t\t}\n\t},\n\tremoveChild:function(oldChild){\n\t\treturn _removeChild(this,oldChild);\n\t},\n\tappendChild:function(newChild){\n\t\treturn this.insertBefore(newChild,null);\n\t},\n\thasChildNodes:function(){\n\t\treturn this.firstChild != null;\n\t},\n\tcloneNode:function(deep){\n\t\treturn cloneNode(this.ownerDocument||this,this,deep);\n\t},\n\t// Modified in DOM Level 2:\n\tnormalize:function(){\n\t\tvar child = this.firstChild;\n\t\twhile(child){\n\t\t\tvar next = child.nextSibling;\n\t\t\tif(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){\n\t\t\t\tthis.removeChild(next);\n\t\t\t\tchild.appendData(next.data);\n\t\t\t}else{\n\t\t\t\tchild.normalize();\n\t\t\t\tchild = next;\n\t\t\t}\n\t\t}\n\t},\n  \t// Introduced in DOM Level 2:\n\tisSupported:function(feature, version){\n\t\treturn this.ownerDocument.implementation.hasFeature(feature,version);\n\t},\n    // Introduced in DOM Level 2:\n    hasAttributes:function(){\n    \treturn this.attributes.length>0;\n    },\n    lookupPrefix:function(namespaceURI){\n    \tvar el = this;\n    \twhile(el){\n    \t\tvar map = el._nsMap;\n    \t\t//console.dir(map)\n    \t\tif(map){\n    \t\t\tfor(var n in map){\n    \t\t\t\tif(map[n] == namespaceURI){\n    \t\t\t\t\treturn n;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tel = el.nodeType == 2?el.ownerDocument : el.parentNode;\n    \t}\n    \treturn null;\n    },\n    // Introduced in DOM Level 3:\n    lookupNamespaceURI:function(prefix){\n    \tvar el = this;\n    \twhile(el){\n    \t\tvar map = el._nsMap;\n    \t\t//console.dir(map)\n    \t\tif(map){\n    \t\t\tif(prefix in map){\n    \t\t\t\treturn map[prefix] ;\n    \t\t\t}\n    \t\t}\n    \t\tel = el.nodeType == 2?el.ownerDocument : el.parentNode;\n    \t}\n    \treturn null;\n    },\n    // Introduced in DOM Level 3:\n    isDefaultNamespace:function(namespaceURI){\n    \tvar prefix = this.lookupPrefix(namespaceURI);\n    \treturn prefix == null;\n    }\n};\n\n\nfunction _xmlEncoder(c){\n\treturn c == '<' && '&lt;' ||\n         c == '>' && '&gt;' ||\n         c == '&' && '&amp;' ||\n         c == '\"' && '&quot;' ||\n         '&#'+c.charCodeAt()+';'\n}\n\n\ncopy(NodeType,Node);\ncopy(NodeType,Node.prototype);\n\n/**\n * @param callback return true for continue,false for break\n * @return boolean true: break visit;\n */\nfunction _visitNode(node,callback){\n\tif(callback(node)){\n\t\treturn true;\n\t}\n\tif(node = node.firstChild){\n\t\tdo{\n\t\t\tif(_visitNode(node,callback)){return true}\n        }while(node=node.nextSibling)\n    }\n}\n\n\n\nfunction Document(){\n}\nfunction _onAddAttribute(doc,el,newAttr){\n\tdoc && doc._inc++;\n\tvar ns = newAttr.namespaceURI ;\n\tif(ns == 'http://www.w3.org/2000/xmlns/'){\n\t\t//update namespace\n\t\tel._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value\n\t}\n}\nfunction _onRemoveAttribute(doc,el,newAttr,remove){\n\tdoc && doc._inc++;\n\tvar ns = newAttr.namespaceURI ;\n\tif(ns == 'http://www.w3.org/2000/xmlns/'){\n\t\t//update namespace\n\t\tdelete el._nsMap[newAttr.prefix?newAttr.localName:'']\n\t}\n}\nfunction _onUpdateChild(doc,el,newChild){\n\tif(doc && doc._inc){\n\t\tdoc._inc++;\n\t\t//update childNodes\n\t\tvar cs = el.childNodes;\n\t\tif(newChild){\n\t\t\tcs[cs.length++] = newChild;\n\t\t}else{\n\t\t\t//console.log(1)\n\t\t\tvar child = el.firstChild;\n\t\t\tvar i = 0;\n\t\t\twhile(child){\n\t\t\t\tcs[i++] = child;\n\t\t\t\tchild =child.nextSibling;\n\t\t\t}\n\t\t\tcs.length = i;\n\t\t}\n\t}\n}\n\n/**\n * attributes;\n * children;\n * \n * writeable properties:\n * nodeValue,Attr:value,CharacterData:data\n * prefix\n */\nfunction _removeChild(parentNode,child){\n\tvar previous = child.previousSibling;\n\tvar next = child.nextSibling;\n\tif(previous){\n\t\tprevious.nextSibling = next;\n\t}else{\n\t\tparentNode.firstChild = next\n\t}\n\tif(next){\n\t\tnext.previousSibling = previous;\n\t}else{\n\t\tparentNode.lastChild = previous;\n\t}\n\t_onUpdateChild(parentNode.ownerDocument,parentNode);\n\treturn child;\n}\n/**\n * preformance key(refChild == null)\n */\nfunction _insertBefore(parentNode,newChild,nextChild){\n\tvar cp = newChild.parentNode;\n\tif(cp){\n\t\tcp.removeChild(newChild);//remove and update\n\t}\n\tif(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){\n\t\tvar newFirst = newChild.firstChild;\n\t\tif (newFirst == null) {\n\t\t\treturn newChild;\n\t\t}\n\t\tvar newLast = newChild.lastChild;\n\t}else{\n\t\tnewFirst = newLast = newChild;\n\t}\n\tvar pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;\n\n\tnewFirst.previousSibling = pre;\n\tnewLast.nextSibling = nextChild;\n\t\n\t\n\tif(pre){\n\t\tpre.nextSibling = newFirst;\n\t}else{\n\t\tparentNode.firstChild = newFirst;\n\t}\n\tif(nextChild == null){\n\t\tparentNode.lastChild = newLast;\n\t}else{\n\t\tnextChild.previousSibling = newLast;\n\t}\n\tdo{\n\t\tnewFirst.parentNode = parentNode;\n\t}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))\n\t_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);\n\t//console.log(parentNode.lastChild.nextSibling == null)\n\tif (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {\n\t\tnewChild.firstChild = newChild.lastChild = null;\n\t}\n\treturn newChild;\n}\nfunction _appendSingleChild(parentNode,newChild){\n\tvar cp = newChild.parentNode;\n\tif(cp){\n\t\tvar pre = parentNode.lastChild;\n\t\tcp.removeChild(newChild);//remove and update\n\t\tvar pre = parentNode.lastChild;\n\t}\n\tvar pre = parentNode.lastChild;\n\tnewChild.parentNode = parentNode;\n\tnewChild.previousSibling = pre;\n\tnewChild.nextSibling = null;\n\tif(pre){\n\t\tpre.nextSibling = newChild;\n\t}else{\n\t\tparentNode.firstChild = newChild;\n\t}\n\tparentNode.lastChild = newChild;\n\t_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);\n\treturn newChild;\n\t//console.log(\"__aa\",parentNode.lastChild.nextSibling == null)\n}\nDocument.prototype = {\n\t//implementation : null,\n\tnodeName :  '#document',\n\tnodeType :  DOCUMENT_NODE,\n\tdoctype :  null,\n\tdocumentElement :  null,\n\t_inc : 1,\n\t\n\tinsertBefore :  function(newChild, refChild){//raises \n\t\tif(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){\n\t\t\tvar child = newChild.firstChild;\n\t\t\twhile(child){\n\t\t\t\tvar next = child.nextSibling;\n\t\t\t\tthis.insertBefore(child,refChild);\n\t\t\t\tchild = next;\n\t\t\t}\n\t\t\treturn newChild;\n\t\t}\n\t\tif(this.documentElement == null && newChild.nodeType == 1){\n\t\t\tthis.documentElement = newChild;\n\t\t}\n\t\t\n\t\treturn _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;\n\t},\n\tremoveChild :  function(oldChild){\n\t\tif(this.documentElement == oldChild){\n\t\t\tthis.documentElement = null;\n\t\t}\n\t\treturn _removeChild(this,oldChild);\n\t},\n\t// Introduced in DOM Level 2:\n\timportNode : function(importedNode,deep){\n\t\treturn importNode(this,importedNode,deep);\n\t},\n\t// Introduced in DOM Level 2:\n\tgetElementById :\tfunction(id){\n\t\tvar rtv = null;\n\t\t_visitNode(this.documentElement,function(node){\n\t\t\tif(node.nodeType == 1){\n\t\t\t\tif(node.getAttribute('id') == id){\n\t\t\t\t\trtv = node;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\treturn rtv;\n\t},\n\t\n\t//document factory method:\n\tcreateElement :\tfunction(tagName){\n\t\tvar node = new Element();\n\t\tnode.ownerDocument = this;\n\t\tnode.nodeName = tagName;\n\t\tnode.tagName = tagName;\n\t\tnode.childNodes = new NodeList();\n\t\tvar attrs\t= node.attributes = new NamedNodeMap();\n\t\tattrs._ownerElement = node;\n\t\treturn node;\n\t},\n\tcreateDocumentFragment :\tfunction(){\n\t\tvar node = new DocumentFragment();\n\t\tnode.ownerDocument = this;\n\t\tnode.childNodes = new NodeList();\n\t\treturn node;\n\t},\n\tcreateTextNode :\tfunction(data){\n\t\tvar node = new Text();\n\t\tnode.ownerDocument = this;\n\t\tnode.appendData(data)\n\t\treturn node;\n\t},\n\tcreateComment :\tfunction(data){\n\t\tvar node = new Comment();\n\t\tnode.ownerDocument = this;\n\t\tnode.appendData(data)\n\t\treturn node;\n\t},\n\tcreateCDATASection :\tfunction(data){\n\t\tvar node = new CDATASection();\n\t\tnode.ownerDocument = this;\n\t\tnode.appendData(data)\n\t\treturn node;\n\t},\n\tcreateProcessingInstruction :\tfunction(target,data){\n\t\tvar node = new ProcessingInstruction();\n\t\tnode.ownerDocument = this;\n\t\tnode.tagName = node.target = target;\n\t\tnode.nodeValue= node.data = data;\n\t\treturn node;\n\t},\n\tcreateAttribute :\tfunction(name){\n\t\tvar node = new Attr();\n\t\tnode.ownerDocument\t= this;\n\t\tnode.name = name;\n\t\tnode.nodeName\t= name;\n\t\tnode.localName = name;\n\t\tnode.specified = true;\n\t\treturn node;\n\t},\n\tcreateEntityReference :\tfunction(name){\n\t\tvar node = new EntityReference();\n\t\tnode.ownerDocument\t= this;\n\t\tnode.nodeName\t= name;\n\t\treturn node;\n\t},\n\t// Introduced in DOM Level 2:\n\tcreateElementNS :\tfunction(namespaceURI,qualifiedName){\n\t\tvar node = new Element();\n\t\tvar pl = qualifiedName.split(':');\n\t\tvar attrs\t= node.attributes = new NamedNodeMap();\n\t\tnode.childNodes = new NodeList();\n\t\tnode.ownerDocument = this;\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.tagName = qualifiedName;\n\t\tnode.namespaceURI = namespaceURI;\n\t\tif(pl.length == 2){\n\t\t\tnode.prefix = pl[0];\n\t\t\tnode.localName = pl[1];\n\t\t}else{\n\t\t\t//el.prefix = null;\n\t\t\tnode.localName = qualifiedName;\n\t\t}\n\t\tattrs._ownerElement = node;\n\t\treturn node;\n\t},\n\t// Introduced in DOM Level 2:\n\tcreateAttributeNS :\tfunction(namespaceURI,qualifiedName){\n\t\tvar node = new Attr();\n\t\tvar pl = qualifiedName.split(':');\n\t\tnode.ownerDocument = this;\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.name = qualifiedName;\n\t\tnode.namespaceURI = namespaceURI;\n\t\tnode.specified = true;\n\t\tif(pl.length == 2){\n\t\t\tnode.prefix = pl[0];\n\t\t\tnode.localName = pl[1];\n\t\t}else{\n\t\t\t//el.prefix = null;\n\t\t\tnode.localName = qualifiedName;\n\t\t}\n\t\treturn node;\n\t}\n};\n_extends(Document,Node);\n\n\nfunction Element() {\n\tthis._nsMap = {};\n};\nElement.prototype = {\n\tnodeType : ELEMENT_NODE,\n\thasAttribute : function(name){\n\t\treturn this.getAttributeNode(name)!=null;\n\t},\n\tgetAttribute : function(name){\n\t\tvar attr = this.getAttributeNode(name);\n\t\treturn attr && attr.value || '';\n\t},\n\tgetAttributeNode : function(name){\n\t\treturn this.attributes.getNamedItem(name);\n\t},\n\tsetAttribute : function(name, value){\n\t\tvar attr = this.ownerDocument.createAttribute(name);\n\t\tattr.value = attr.nodeValue = \"\" + value;\n\t\tthis.setAttributeNode(attr)\n\t},\n\tremoveAttribute : function(name){\n\t\tvar attr = this.getAttributeNode(name)\n\t\tattr && this.removeAttributeNode(attr);\n\t},\n\t\n\t//four real opeartion method\n\tappendChild:function(newChild){\n\t\tif(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){\n\t\t\treturn this.insertBefore(newChild,null);\n\t\t}else{\n\t\t\treturn _appendSingleChild(this,newChild);\n\t\t}\n\t},\n\tsetAttributeNode : function(newAttr){\n\t\treturn this.attributes.setNamedItem(newAttr);\n\t},\n\tsetAttributeNodeNS : function(newAttr){\n\t\treturn this.attributes.setNamedItemNS(newAttr);\n\t},\n\tremoveAttributeNode : function(oldAttr){\n\t\treturn this.attributes.removeNamedItem(oldAttr.nodeName);\n\t},\n\t//get real attribute name,and remove it by removeAttributeNode\n\tremoveAttributeNS : function(namespaceURI, localName){\n\t\tvar old = this.getAttributeNodeNS(namespaceURI, localName);\n\t\told && this.removeAttributeNode(old);\n\t},\n\t\n\thasAttributeNS : function(namespaceURI, localName){\n\t\treturn this.getAttributeNodeNS(namespaceURI, localName)!=null;\n\t},\n\tgetAttributeNS : function(namespaceURI, localName){\n\t\tvar attr = this.getAttributeNodeNS(namespaceURI, localName);\n\t\treturn attr && attr.value || '';\n\t},\n\tsetAttributeNS : function(namespaceURI, qualifiedName, value){\n\t\tvar attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);\n\t\tattr.value = attr.nodeValue = value;\n\t\tthis.setAttributeNode(attr)\n\t},\n\tgetAttributeNodeNS : function(namespaceURI, localName){\n\t\treturn this.attributes.getNamedItemNS(namespaceURI, localName);\n\t},\n\t\n\tgetElementsByTagName : function(tagName){\n\t\treturn new LiveNodeList(this,function(base){\n\t\t\tvar ls = [];\n\t\t\t_visitNode(base,function(node){\n\t\t\t\tif(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){\n\t\t\t\t\tls.push(node);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn ls;\n\t\t});\n\t},\n\tgetElementsByTagNameNS : function(namespaceURI, localName){\n\t\treturn new LiveNodeList(this,function(base){\n\t\t\tvar ls = [];\n\t\t\t_visitNode(base,function(node){\n\t\t\t\tif(node !== base && node.nodeType === ELEMENT_NODE && node.namespaceURI === namespaceURI && (localName === '*' || node.localName == localName)){\n\t\t\t\t\tls.push(node);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn ls;\n\t\t});\n\t}\n};\nDocument.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;\nDocument.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;\n\n\n_extends(Element,Node);\nfunction Attr() {\n};\nAttr.prototype.nodeType = ATTRIBUTE_NODE;\n_extends(Attr,Node);\n\n\nfunction CharacterData() {\n};\nCharacterData.prototype = {\n\tdata : '',\n\tsubstringData : function(offset, count) {\n\t\treturn this.data.substring(offset, offset+count);\n\t},\n\tappendData: function(text) {\n\t\ttext = this.data+text;\n\t\tthis.nodeValue = this.data = text;\n\t\tthis.length = text.length;\n\t},\n\tinsertData: function(offset,text) {\n\t\tthis.replaceData(offset,0,text);\n\t\n\t},\n\tappendChild:function(newChild){\n\t\t//if(!(newChild instanceof CharacterData)){\n\t\t\tthrow new Error(ExceptionMessage[3])\n\t\t//}\n\t\treturn Node.prototype.appendChild.apply(this,arguments)\n\t},\n\tdeleteData: function(offset, count) {\n\t\tthis.replaceData(offset,count,\"\");\n\t},\n\treplaceData: function(offset, count, text) {\n\t\tvar start = this.data.substring(0,offset);\n\t\tvar end = this.data.substring(offset+count);\n\t\ttext = start + text + end;\n\t\tthis.nodeValue = this.data = text;\n\t\tthis.length = text.length;\n\t}\n}\n_extends(CharacterData,Node);\nfunction Text() {\n};\nText.prototype = {\n\tnodeName : \"#text\",\n\tnodeType : TEXT_NODE,\n\tsplitText : function(offset) {\n\t\tvar text = this.data;\n\t\tvar newText = text.substring(offset);\n\t\ttext = text.substring(0, offset);\n\t\tthis.data = this.nodeValue = text;\n\t\tthis.length = text.length;\n\t\tvar newNode = this.ownerDocument.createTextNode(newText);\n\t\tif(this.parentNode){\n\t\t\tthis.parentNode.insertBefore(newNode, this.nextSibling);\n\t\t}\n\t\treturn newNode;\n\t}\n}\n_extends(Text,CharacterData);\nfunction Comment() {\n};\nComment.prototype = {\n\tnodeName : \"#comment\",\n\tnodeType : COMMENT_NODE\n}\n_extends(Comment,CharacterData);\n\nfunction CDATASection() {\n};\nCDATASection.prototype = {\n\tnodeName : \"#cdata-section\",\n\tnodeType : CDATA_SECTION_NODE\n}\n_extends(CDATASection,CharacterData);\n\n\nfunction DocumentType() {\n};\nDocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;\n_extends(DocumentType,Node);\n\nfunction Notation() {\n};\nNotation.prototype.nodeType = NOTATION_NODE;\n_extends(Notation,Node);\n\nfunction Entity() {\n};\nEntity.prototype.nodeType = ENTITY_NODE;\n_extends(Entity,Node);\n\nfunction EntityReference() {\n};\nEntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;\n_extends(EntityReference,Node);\n\nfunction DocumentFragment() {\n};\nDocumentFragment.prototype.nodeName =\t\"#document-fragment\";\nDocumentFragment.prototype.nodeType =\tDOCUMENT_FRAGMENT_NODE;\n_extends(DocumentFragment,Node);\n\n\nfunction ProcessingInstruction() {\n}\nProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;\n_extends(ProcessingInstruction,Node);\nfunction XMLSerializer(){}\nXMLSerializer.prototype.serializeToString = function(node){\n\tvar buf = [];\n\tserializeToString(node,buf);\n\treturn buf.join('');\n}\nNode.prototype.toString =function(){\n\treturn XMLSerializer.prototype.serializeToString(this);\n}\nfunction serializeToString(node,buf){\n\tswitch(node.nodeType){\n\tcase ELEMENT_NODE:\n\t\tvar attrs = node.attributes;\n\t\tvar len = attrs.length;\n\t\tvar child = node.firstChild;\n\t\tvar nodeName = node.tagName;\n\t\tvar isHTML = htmlns === node.namespaceURI\n\t\tbuf.push('<',nodeName);\n\t\tfor(var i=0;i<len;i++){\n\t\t\tserializeToString(attrs.item(i),buf,isHTML);\n\t\t}\n\t\tif(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){\n\t\t\tbuf.push('>');\n\t\t\t//if is cdata child node\n\t\t\tif(isHTML && /^script$/i.test(nodeName)){\n\t\t\t\tif(child){\n\t\t\t\t\tbuf.push(child.data);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\twhile(child){\n\t\t\t\t\tserializeToString(child,buf);\n\t\t\t\t\tchild = child.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf.push('</',nodeName,'>');\n\t\t}else{\n\t\t\tbuf.push('/>');\n\t\t}\n\t\treturn;\n\tcase DOCUMENT_NODE:\n\tcase DOCUMENT_FRAGMENT_NODE:\n\t\tvar child = node.firstChild;\n\t\twhile(child){\n\t\t\tserializeToString(child,buf);\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t\treturn;\n\tcase ATTRIBUTE_NODE:\n\t\treturn buf.push(' ',node.name,'=\"',node.value.replace(/[<&\"]/g,_xmlEncoder),'\"');\n\tcase TEXT_NODE:\n\t\treturn buf.push(node.data.replace(/[<&]/g,_xmlEncoder));\n\tcase CDATA_SECTION_NODE:\n\t\treturn buf.push( '<![CDATA[',node.data,']]>');\n\tcase COMMENT_NODE:\n\t\treturn buf.push( \"<!--\",node.data,\"-->\");\n\tcase DOCUMENT_TYPE_NODE:\n\t\tvar pubid = node.publicId;\n\t\tvar sysid = node.systemId;\n\t\tbuf.push('<!DOCTYPE ',node.name);\n\t\tif(pubid){\n\t\t\tbuf.push(' PUBLIC \"',pubid);\n\t\t\tif (sysid && sysid!='.') {\n\t\t\t\tbuf.push( '\" \"',sysid);\n\t\t\t}\n\t\t\tbuf.push('\">');\n\t\t}else if(sysid && sysid!='.'){\n\t\t\tbuf.push(' SYSTEM \"',sysid,'\">');\n\t\t}else{\n\t\t\tvar sub = node.internalSubset;\n\t\t\tif(sub){\n\t\t\t\tbuf.push(\" [\",sub,\"]\");\n\t\t\t}\n\t\t\tbuf.push(\">\");\n\t\t}\n\t\treturn;\n\tcase PROCESSING_INSTRUCTION_NODE:\n\t\treturn buf.push( \"<?\",node.target,\" \",node.data,\"?>\");\n\tcase ENTITY_REFERENCE_NODE:\n\t\treturn buf.push( '&',node.nodeName,';');\n\t//case ENTITY_NODE:\n\t//case NOTATION_NODE:\n\tdefault:\n\t\tbuf.push('??',node.nodeName);\n\t}\n}\nfunction importNode(doc,node,deep){\n\tvar node2;\n\tswitch (node.nodeType) {\n\tcase ELEMENT_NODE:\n\t\tnode2 = node.cloneNode(false);\n\t\tnode2.ownerDocument = doc;\n\t\t//var attrs = node2.attributes;\n\t\t//var len = attrs.length;\n\t\t//for(var i=0;i<len;i++){\n\t\t\t//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));\n\t\t//}\n\tcase DOCUMENT_FRAGMENT_NODE:\n\t\tbreak;\n\tcase ATTRIBUTE_NODE:\n\t\tdeep = true;\n\t\tbreak;\n\t//case ENTITY_REFERENCE_NODE:\n\t//case PROCESSING_INSTRUCTION_NODE:\n\t////case TEXT_NODE:\n\t//case CDATA_SECTION_NODE:\n\t//case COMMENT_NODE:\n\t//\tdeep = false;\n\t//\tbreak;\n\t//case DOCUMENT_NODE:\n\t//case DOCUMENT_TYPE_NODE:\n\t//cannot be imported.\n\t//case ENTITY_NODE:\n\t//case NOTATION_NODE\n\t//can not hit in level3\n\t//default:throw e;\n\t}\n\tif(!node2){\n\t\tnode2 = node.cloneNode(false);//false\n\t}\n\tnode2.ownerDocument = doc;\n\tnode2.parentNode = null;\n\tif(deep){\n\t\tvar child = node.firstChild;\n\t\twhile(child){\n\t\t\tnode2.appendChild(importNode(doc,child,deep));\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t}\n\treturn node2;\n}\n//\n//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,\n//\t\t\t\t\tattributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};\nfunction cloneNode(doc,node,deep){\n\tvar node2 = new node.constructor();\n\tfor(var n in node){\n\t\tvar v = node[n];\n\t\tif(typeof v != 'object' ){\n\t\t\tif(v != node2[n]){\n\t\t\t\tnode2[n] = v;\n\t\t\t}\n\t\t}\n\t}\n\tif(node.childNodes){\n\t\tnode2.childNodes = new NodeList();\n\t}\n\tnode2.ownerDocument = doc;\n\tswitch (node2.nodeType) {\n\tcase ELEMENT_NODE:\n\t\tvar attrs\t= node.attributes;\n\t\tvar attrs2\t= node2.attributes = new NamedNodeMap();\n\t\tvar len = attrs.length\n\t\tattrs2._ownerElement = node2;\n\t\tfor(var i=0;i<len;i++){\n\t\t\tnode2.setAttributeNode(cloneNode(doc,attrs.item(i),true));\n\t\t}\n\t\tbreak;;\n\tcase ATTRIBUTE_NODE:\n\t\tdeep = true;\n\t}\n\tif(deep){\n\t\tvar child = node.firstChild;\n\t\twhile(child){\n\t\t\tnode2.appendChild(cloneNode(doc,child,deep));\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t}\n\treturn node2;\n}\n\nfunction __set__(object,key,value){\n\tobject[key] = value\n}\n//do dynamic\ntry{\n\tif(Object.defineProperty){\n\t\tObject.defineProperty(LiveNodeList.prototype,'length',{\n\t\t\tget:function(){\n\t\t\t\t_updateLiveList(this);\n\t\t\t\treturn this.$$length;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(Node.prototype,'textContent',{\n\t\t\tget:function(){\n\t\t\t\treturn getTextContent(this);\n\t\t\t},\n\t\t\tset:function(data){\n\t\t\t\tswitch(this.nodeType){\n\t\t\t\tcase 1:\n\t\t\t\tcase 11:\n\t\t\t\t\twhile(this.firstChild){\n\t\t\t\t\t\tthis.removeChild(this.firstChild);\n\t\t\t\t\t}\n\t\t\t\t\tif(data || String(data)){\n\t\t\t\t\t\tthis.appendChild(this.ownerDocument.createTextNode(data));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t//TODO:\n\t\t\t\t\tthis.data = data;\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tthis.nodeValue = data;\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\t\n\t\tfunction getTextContent(node){\n\t\t\tswitch(node.nodeType){\n\t\t\tcase 1:\n\t\t\tcase 11:\n\t\t\t\tvar buf = [];\n\t\t\t\tnode = node.firstChild;\n\t\t\t\twhile(node){\n\t\t\t\t\tif(node.nodeType!==7 && node.nodeType !==8){\n\t\t\t\t\t\tbuf.push(getTextContent(node));\n\t\t\t\t\t}\n\t\t\t\t\tnode = node.nextSibling;\n\t\t\t\t}\n\t\t\t\treturn buf.join('');\n\t\t\tdefault:\n\t\t\t\treturn node.nodeValue;\n\t\t\t}\n\t\t}\n\t\t__set__ = function(object,key,value){\n\t\t\t//console.log(value)\n\t\t\tobject['$$'+key] = value\n\t\t}\n\t}\n}catch(e){//ie8\n}\n\nif(typeof require == 'function'){\n\texports.DOMImplementation = DOMImplementation;\n\texports.XMLSerializer = XMLSerializer;\n}\n\n},{}],32:[function(require,module,exports){\n//[4]   \tNameStartChar\t   ::=   \t\":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\r\n//[4a]   \tNameChar\t   ::=   \tNameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\r\n//[5]   \tName\t   ::=   \tNameStartChar (NameChar)*\r\nvar nameStartChar = /[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]///\\u10000-\\uEFFFF\r\nvar nameChar = new RegExp(\"[\\\\-\\\\.0-9\"+nameStartChar.source.slice(1,-1)+\"\\u00B7\\u0300-\\u036F\\\\ux203F-\\u2040]\");\r\nvar tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\\:'+nameStartChar.source+nameChar.source+'*)?$');\r\n//var tagNamePattern = /^[a-zA-Z_][\\w\\-\\.]*(?:\\:[a-zA-Z_][\\w\\-\\.]*)?$/\r\n//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\r\n\r\n//S_TAG,\tS_ATTR,\tS_EQ,\tS_V\r\n//S_ATTR_S,\tS_E,\tS_S,\tS_C\r\nvar S_TAG = 0;//tag name offerring\r\nvar S_ATTR = 1;//attr name offerring \r\nvar S_ATTR_S=2;//attr name end and space offer\r\nvar S_EQ = 3;//=space?\r\nvar S_V = 4;//attr value(no quot value only)\r\nvar S_E = 5;//attr value end and no space(quot end)\r\nvar S_S = 6;//(attr value end || tag end ) && (space offer)\r\nvar S_C = 7;//closed el<el />\r\n\r\nfunction XMLReader(){\r\n\t\r\n}\r\n\r\nXMLReader.prototype = {\r\n\tparse:function(source,defaultNSMap,entityMap){\r\n\t\tvar domBuilder = this.domBuilder;\r\n\t\tdomBuilder.startDocument();\r\n\t\t_copy(defaultNSMap ,defaultNSMap = {})\r\n\t\tparse(source,defaultNSMap,entityMap,\r\n\t\t\t\tdomBuilder,this.errorHandler);\r\n\t\tdomBuilder.endDocument();\r\n\t}\r\n}\r\nfunction parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){\r\n  function fixedFromCharCode(code) {\r\n\t\t// String.prototype.fromCharCode does not supports\r\n\t\t// > 2 bytes unicode chars directly\r\n\t\tif (code > 0xffff) {\r\n\t\t\tcode -= 0x10000;\r\n\t\t\tvar surrogate1 = 0xd800 + (code >> 10)\r\n\t\t\t\t, surrogate2 = 0xdc00 + (code & 0x3ff);\r\n\r\n\t\t\treturn String.fromCharCode(surrogate1, surrogate2);\r\n\t\t} else {\r\n\t\t\treturn String.fromCharCode(code);\r\n\t\t}\r\n\t}\r\n\tfunction entityReplacer(a){\r\n\t\tvar k = a.slice(1,-1);\r\n\t\tif(k in entityMap){\r\n\t\t\treturn entityMap[k]; \r\n\t\t}else if(k.charAt(0) === '#'){\r\n\t\t\treturn fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))\r\n\t\t}else{\r\n\t\t\terrorHandler.error('entity not found:'+a);\r\n\t\t\treturn a;\r\n\t\t}\r\n\t}\r\n\tfunction appendText(end){//has some bugs\r\n\t\tvar xt = source.substring(start,end).replace(/&#?\\w+;/g,entityReplacer);\r\n\t\tlocator&&position(start);\r\n\t\tdomBuilder.characters(xt,0,end-start);\r\n\t\tstart = end\r\n\t}\r\n\tfunction position(start,m){\r\n\t\twhile(start>=endPos && (m = linePattern.exec(source))){\r\n\t\t\tstartPos = m.index;\r\n\t\t\tendPos = startPos + m[0].length;\r\n\t\t\tlocator.lineNumber++;\r\n\t\t\t//console.log('line++:',locator,startPos,endPos)\r\n\t\t}\r\n\t\tlocator.columnNumber = start-startPos+1;\r\n\t}\r\n\tvar startPos = 0;\r\n\tvar endPos = 0;\r\n\tvar linePattern = /.+(?:\\r\\n?|\\n)|.*$/g\r\n\tvar locator = domBuilder.locator;\r\n\t\r\n\tvar parseStack = [{currentNSMap:defaultNSMapCopy}]\r\n\tvar closeMap = {};\r\n\tvar start = 0;\r\n\twhile(true){\r\n\t\tvar i = source.indexOf('<',start);\r\n\t\tif(i<0){\r\n\t\t\tif(!source.substr(start).match(/^\\s*$/)){\r\n\t\t\t\tvar doc = domBuilder.document;\r\n    \t\t\tvar text = doc.createTextNode(source.substr(start));\r\n    \t\t\tdoc.appendChild(text);\r\n    \t\t\tdomBuilder.currentElement = text;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(i>start){\r\n\t\t\tappendText(i);\r\n\t\t}\r\n\t\tswitch(source.charAt(i+1)){\r\n\t\tcase '/':\r\n\t\t\tvar end = source.indexOf('>',i+3);\r\n\t\t\tvar tagName = source.substring(i+2,end);\r\n\t\t\tvar config = parseStack.pop();\r\n\t\t\tvar localNSMap = config.localNSMap;\r\n\t\t\t\r\n\t        if(config.tagName != tagName){\r\n\t            errorHandler.fatalError(\"end tag name: \"+tagName+' is not match the current start tagName:'+config.tagName );\r\n\t        }\r\n\t\t\tdomBuilder.endElement(config.uri,config.localName,tagName);\r\n\t\t\tif(localNSMap){\r\n\t\t\t\tfor(var prefix in localNSMap){\r\n\t\t\t\t\tdomBuilder.endPrefixMapping(prefix) ;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tend++;\r\n\t\t\tbreak;\r\n\t\t\t// end elment\r\n\t\tcase '?':// <?...?>\r\n\t\t\tlocator&&position(i);\r\n\t\t\tend = parseInstruction(source,i,domBuilder);\r\n\t\t\tbreak;\r\n\t\tcase '!':// <!doctype,<![CDATA,<!--\r\n\t\t\tlocator&&position(i);\r\n\t\t\tend = parseDCC(source,i,domBuilder,errorHandler);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\ttry{\r\n\t\t\t\tlocator&&position(i);\r\n\t\t\t\t\r\n\t\t\t\tvar el = new ElementAttributes();\r\n\t\t\t\t\r\n\t\t\t\t//elStartEnd\r\n\t\t\t\tvar end = parseElementStartPart(source,i,el,entityReplacer,errorHandler);\r\n\t\t\t\tvar len = el.length;\r\n\t\t\t\t//position fixed\r\n\t\t\t\tif(len && locator){\r\n\t\t\t\t\tvar backup = copyLocator(locator,{});\r\n\t\t\t\t\tfor(var i = 0;i<len;i++){\r\n\t\t\t\t\t\tvar a = el[i];\r\n\t\t\t\t\t\tposition(a.offset);\r\n\t\t\t\t\t\ta.offset = copyLocator(locator,{});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcopyLocator(backup,locator);\r\n\t\t\t\t}\r\n\t\t\t\tif(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){\r\n\t\t\t\t\tel.closed = true;\r\n\t\t\t\t\tif(!entityMap.nbsp){\r\n\t\t\t\t\t\terrorHandler.warning('unclosed xml attribute');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tappendElement(el,domBuilder,parseStack);\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tif(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){\r\n\t\t\t\t\tend = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tend++;\r\n\t\t\t\t}\r\n\t\t\t}catch(e){\r\n\t\t\t\terrorHandler.error('element parse error: '+e);\r\n\t\t\t\tend = -1;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tif(end<0){\r\n\t\t\t//TODO: sax\r\n\t\t\tappendText(i+1);\r\n\t\t}else{\r\n\t\t\tstart = end;\r\n\t\t}\r\n\t}\r\n}\r\nfunction copyLocator(f,t){\r\n\tt.lineNumber = f.lineNumber;\r\n\tt.columnNumber = f.columnNumber;\r\n\treturn t;\r\n\t\r\n}\r\n\r\n/**\r\n * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);\r\n * @return end of the elementStartPart(end of elementEndPart for selfClosed el)\r\n */\r\nfunction parseElementStartPart(source,start,el,entityReplacer,errorHandler){\r\n\tvar attrName;\r\n\tvar value;\r\n\tvar p = ++start;\r\n\tvar s = S_TAG;//status\r\n\twhile(true){\r\n\t\tvar c = source.charAt(p);\r\n\t\tswitch(c){\r\n\t\tcase '=':\r\n\t\t\tif(s === S_ATTR){//attrName\r\n\t\t\t\tattrName = source.slice(start,p);\r\n\t\t\t\ts = S_EQ;\r\n\t\t\t}else if(s === S_ATTR_S){\r\n\t\t\t\ts = S_EQ;\r\n\t\t\t}else{\r\n\t\t\t\t//fatalError: equal must after attrName or space after attrName\r\n\t\t\t\tthrow new Error('attribute equal must after attrName');\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase '\\'':\r\n\t\tcase '\"':\r\n\t\t\tif(s === S_EQ){//equal\r\n\t\t\t\tstart = p+1;\r\n\t\t\t\tp = source.indexOf(c,start)\r\n\t\t\t\tif(p>0){\r\n\t\t\t\t\tvalue = source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);\r\n\t\t\t\t\tel.add(attrName,value,start-1);\r\n\t\t\t\t\ts = S_E;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t//fatalError: no end quot match\r\n\t\t\t\t\tthrow new Error('attribute value no end \\''+c+'\\' match');\r\n\t\t\t\t}\r\n\t\t\t}else if(s == S_V){\r\n\t\t\t\tvalue = source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);\r\n\t\t\t\t//console.log(attrName,value,start,p)\r\n\t\t\t\tel.add(attrName,value,start);\r\n\t\t\t\t//console.dir(el)\r\n\t\t\t\terrorHandler.warning('attribute \"'+attrName+'\" missed start quot('+c+')!!');\r\n\t\t\t\tstart = p+1;\r\n\t\t\t\ts = S_E\r\n\t\t\t}else{\r\n\t\t\t\t//fatalError: no equal before\r\n\t\t\t\tthrow new Error('attribute value must after \"=\"');\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase '/':\r\n\t\t\tswitch(s){\r\n\t\t\tcase S_TAG:\r\n\t\t\t\tel.setTagName(source.slice(start,p));\r\n\t\t\tcase S_E:\r\n\t\t\tcase S_S:\r\n\t\t\tcase S_C:\r\n\t\t\t\ts = S_C;\r\n\t\t\t\tel.closed = true;\r\n\t\t\tcase S_V:\r\n\t\t\tcase S_ATTR:\r\n\t\t\tcase S_ATTR_S:\r\n\t\t\t\tbreak;\r\n\t\t\t//case S_EQ:\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(\"attribute invalid close char('/')\")\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase ''://end document\r\n\t\t\t//throw new Error('unexpected end of input')\r\n\t\t\terrorHandler.error('unexpected end of input');\r\n\t\tcase '>':\r\n\t\t\tswitch(s){\r\n\t\t\tcase S_TAG:\r\n\t\t\t\tel.setTagName(source.slice(start,p));\r\n\t\t\tcase S_E:\r\n\t\t\tcase S_S:\r\n\t\t\tcase S_C:\r\n\t\t\t\tbreak;//normal\r\n\t\t\tcase S_V://Compatible state\r\n\t\t\tcase S_ATTR:\r\n\t\t\t\tvalue = source.slice(start,p);\r\n\t\t\t\tif(value.slice(-1) === '/'){\r\n\t\t\t\t\tel.closed  = true;\r\n\t\t\t\t\tvalue = value.slice(0,-1)\r\n\t\t\t\t}\r\n\t\t\tcase S_ATTR_S:\r\n\t\t\t\tif(s === S_ATTR_S){\r\n\t\t\t\t\tvalue = attrName;\r\n\t\t\t\t}\r\n\t\t\t\tif(s == S_V){\r\n\t\t\t\t\terrorHandler.warning('attribute \"'+value+'\" missed quot(\")!!');\r\n\t\t\t\t\tel.add(attrName,value.replace(/&#?\\w+;/g,entityReplacer),start)\r\n\t\t\t\t}else{\r\n\t\t\t\t\terrorHandler.warning('attribute \"'+value+'\" missed value!! \"'+value+'\" instead!!')\r\n\t\t\t\t\tel.add(value,value,start)\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase S_EQ:\r\n\t\t\t\tthrow new Error('attribute value missed!!');\r\n\t\t\t}\r\n//\t\t\tconsole.log(tagName,tagNamePattern,tagNamePattern.test(tagName))\r\n\t\t\treturn p;\r\n\t\t/*xml space '\\x20' | #x9 | #xD | #xA; */\r\n\t\tcase '\\u0080':\r\n\t\t\tc = ' ';\r\n\t\tdefault:\r\n\t\t\tif(c<= ' '){//space\r\n\t\t\t\tswitch(s){\r\n\t\t\t\tcase S_TAG:\r\n\t\t\t\t\tel.setTagName(source.slice(start,p));//tagName\r\n\t\t\t\t\ts = S_S;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase S_ATTR:\r\n\t\t\t\t\tattrName = source.slice(start,p)\r\n\t\t\t\t\ts = S_ATTR_S;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase S_V:\r\n\t\t\t\t\tvar value = source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);\r\n\t\t\t\t\terrorHandler.warning('attribute \"'+value+'\" missed quot(\")!!');\r\n\t\t\t\t\tel.add(attrName,value,start)\r\n\t\t\t\tcase S_E:\r\n\t\t\t\t\ts = S_S;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//case S_S:\r\n\t\t\t\t//case S_EQ:\r\n\t\t\t\t//case S_ATTR_S:\r\n\t\t\t\t//\tvoid();break;\r\n\t\t\t\t//case S_C:\r\n\t\t\t\t\t//ignore warning\r\n\t\t\t\t}\r\n\t\t\t}else{//not space\r\n//S_TAG,\tS_ATTR,\tS_EQ,\tS_V\r\n//S_ATTR_S,\tS_E,\tS_S,\tS_C\r\n\t\t\t\tswitch(s){\r\n\t\t\t\t//case S_TAG:void();break;\r\n\t\t\t\t//case S_ATTR:void();break;\r\n\t\t\t\t//case S_V:void();break;\r\n\t\t\t\tcase S_ATTR_S:\r\n\t\t\t\t\terrorHandler.warning('attribute \"'+attrName+'\" missed value!! \"'+attrName+'\" instead!!')\r\n\t\t\t\t\tel.add(attrName,attrName,start);\r\n\t\t\t\t\tstart = p;\r\n\t\t\t\t\ts = S_ATTR;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase S_E:\r\n\t\t\t\t\terrorHandler.warning('attribute space is required\"'+attrName+'\"!!')\r\n\t\t\t\tcase S_S:\r\n\t\t\t\t\ts = S_ATTR;\r\n\t\t\t\t\tstart = p;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase S_EQ:\r\n\t\t\t\t\ts = S_V;\r\n\t\t\t\t\tstart = p;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase S_C:\r\n\t\t\t\t\tthrow new Error(\"elements closed character '/' and '>' must be connected to\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tp++;\r\n\t}\r\n}\r\n/**\r\n * @return end of the elementStartPart(end of elementEndPart for selfClosed el)\r\n */\r\nfunction appendElement(el,domBuilder,parseStack){\r\n\tvar tagName = el.tagName;\r\n\tvar localNSMap = null;\r\n\tvar currentNSMap = parseStack[parseStack.length-1].currentNSMap;\r\n\tvar i = el.length;\r\n\twhile(i--){\r\n\t\tvar a = el[i];\r\n\t\tvar qName = a.qName;\r\n\t\tvar value = a.value;\r\n\t\tvar nsp = qName.indexOf(':');\r\n\t\tif(nsp>0){\r\n\t\t\tvar prefix = a.prefix = qName.slice(0,nsp);\r\n\t\t\tvar localName = qName.slice(nsp+1);\r\n\t\t\tvar nsPrefix = prefix === 'xmlns' && localName\r\n\t\t}else{\r\n\t\t\tlocalName = qName;\r\n\t\t\tprefix = null\r\n\t\t\tnsPrefix = qName === 'xmlns' && ''\r\n\t\t}\r\n\t\t//can not set prefix,because prefix !== ''\r\n\t\ta.localName = localName ;\r\n\t\t//prefix == null for no ns prefix attribute \r\n\t\tif(nsPrefix !== false){//hack!!\r\n\t\t\tif(localNSMap == null){\r\n\t\t\t\tlocalNSMap = {}\r\n\t\t\t\t//console.log(currentNSMap,0)\r\n\t\t\t\t_copy(currentNSMap,currentNSMap={})\r\n\t\t\t\t//console.log(currentNSMap,1)\r\n\t\t\t}\r\n\t\t\tcurrentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\r\n\t\t\ta.uri = 'http://www.w3.org/2000/xmlns/'\r\n\t\t\tdomBuilder.startPrefixMapping(nsPrefix, value) \r\n\t\t}\r\n\t}\r\n\tvar i = el.length;\r\n\twhile(i--){\r\n\t\ta = el[i];\r\n\t\tvar prefix = a.prefix;\r\n\t\tif(prefix){//no prefix attribute has no namespace\r\n\t\t\tif(prefix === 'xml'){\r\n\t\t\t\ta.uri = 'http://www.w3.org/XML/1998/namespace';\r\n\t\t\t}if(prefix !== 'xmlns'){\r\n\t\t\t\ta.uri = currentNSMap[prefix]\r\n\t\t\t\t\r\n\t\t\t\t//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tvar nsp = tagName.indexOf(':');\r\n\tif(nsp>0){\r\n\t\tprefix = el.prefix = tagName.slice(0,nsp);\r\n\t\tlocalName = el.localName = tagName.slice(nsp+1);\r\n\t}else{\r\n\t\tprefix = null;//important!!\r\n\t\tlocalName = el.localName = tagName;\r\n\t}\r\n\t//no prefix element has default namespace\r\n\tvar ns = el.uri = currentNSMap[prefix || ''];\r\n\tdomBuilder.startElement(ns,localName,tagName,el);\r\n\t//endPrefixMapping and startPrefixMapping have not any help for dom builder\r\n\t//localNSMap = null\r\n\tif(el.closed){\r\n\t\tdomBuilder.endElement(ns,localName,tagName);\r\n\t\tif(localNSMap){\r\n\t\t\tfor(prefix in localNSMap){\r\n\t\t\t\tdomBuilder.endPrefixMapping(prefix) \r\n\t\t\t}\r\n\t\t}\r\n\t}else{\r\n\t\tel.currentNSMap = currentNSMap;\r\n\t\tel.localNSMap = localNSMap;\r\n\t\tparseStack.push(el);\r\n\t}\r\n}\r\nfunction parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){\r\n\tif(/^(?:script|textarea)$/i.test(tagName)){\r\n\t\tvar elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);\r\n\t\tvar text = source.substring(elStartEnd+1,elEndStart);\r\n\t\tif(/[&<]/.test(text)){\r\n\t\t\tif(/^script$/i.test(tagName)){\r\n\t\t\t\t//if(!/\\]\\]>/.test(text)){\r\n\t\t\t\t\t//lexHandler.startCDATA();\r\n\t\t\t\t\tdomBuilder.characters(text,0,text.length);\r\n\t\t\t\t\t//lexHandler.endCDATA();\r\n\t\t\t\t\treturn elEndStart;\r\n\t\t\t\t//}\r\n\t\t\t}//}else{//text area\r\n\t\t\t\ttext = text.replace(/&#?\\w+;/g,entityReplacer);\r\n\t\t\t\tdomBuilder.characters(text,0,text.length);\r\n\t\t\t\treturn elEndStart;\r\n\t\t\t//}\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\treturn elStartEnd+1;\r\n}\r\nfunction fixSelfClosed(source,elStartEnd,tagName,closeMap){\r\n\t//if(tagName in closeMap){\r\n\tvar pos = closeMap[tagName];\r\n\tif(pos == null){\r\n\t\t//console.log(tagName)\r\n\t\tpos = closeMap[tagName] = source.lastIndexOf('</'+tagName+'>')\r\n\t}\r\n\treturn pos<elStartEnd;\r\n\t//} \r\n}\r\nfunction _copy(source,target){\r\n\tfor(var n in source){target[n] = source[n]}\r\n}\r\nfunction parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'\r\n\tvar next= source.charAt(start+2)\r\n\tswitch(next){\r\n\tcase '-':\r\n\t\tif(source.charAt(start + 3) === '-'){\r\n\t\t\tvar end = source.indexOf('-->',start+4);\r\n\t\t\t//append comment source.substring(4,end)//<!--\r\n\t\t\tif(end>start){\r\n\t\t\t\tdomBuilder.comment(source,start+4,end-start-4);\r\n\t\t\t\treturn end+3;\r\n\t\t\t}else{\r\n\t\t\t\terrorHandler.error(\"Unclosed comment\");\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t//error\r\n\t\t\treturn -1;\r\n\t\t}\r\n\tdefault:\r\n\t\tif(source.substr(start+3,6) == 'CDATA['){\r\n\t\t\tvar end = source.indexOf(']]>',start+9);\r\n\t\t\tdomBuilder.startCDATA();\r\n\t\t\tdomBuilder.characters(source,start+9,end-start-9);\r\n\t\t\tdomBuilder.endCDATA() \r\n\t\t\treturn end+3;\r\n\t\t}\r\n\t\t//<!DOCTYPE\r\n\t\t//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) \r\n\t\tvar matchs = split(source,start);\r\n\t\tvar len = matchs.length;\r\n\t\tif(len>1 && /!doctype/i.test(matchs[0][0])){\r\n\t\t\tvar name = matchs[1][0];\r\n\t\t\tvar pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]\r\n\t\t\tvar sysid = len>4 && matchs[4][0];\r\n\t\t\tvar lastMatch = matchs[len-1]\r\n\t\t\tdomBuilder.startDTD(name,pubid && pubid.replace(/^(['\"])(.*?)\\1$/,'$2'),\r\n\t\t\t\t\tsysid && sysid.replace(/^(['\"])(.*?)\\1$/,'$2'));\r\n\t\t\tdomBuilder.endDTD();\r\n\t\t\t\r\n\t\t\treturn lastMatch.index+lastMatch[0].length\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\n\r\n\r\nfunction parseInstruction(source,start,domBuilder){\r\n\tvar end = source.indexOf('?>',start);\r\n\tif(end){\r\n\t\tvar match = source.substring(start,end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);\r\n\t\tif(match){\r\n\t\t\tvar len = match[0].length;\r\n\t\t\tdomBuilder.processingInstruction(match[1], match[2]) ;\r\n\t\t\treturn end+2;\r\n\t\t}else{//error\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\n/**\r\n * @param source\r\n */\r\nfunction ElementAttributes(source){\r\n\t\r\n}\r\nElementAttributes.prototype = {\r\n\tsetTagName:function(tagName){\r\n\t\tif(!tagNamePattern.test(tagName)){\r\n\t\t\tthrow new Error('invalid tagName:'+tagName)\r\n\t\t}\r\n\t\tthis.tagName = tagName\r\n\t},\r\n\tadd:function(qName,value,offset){\r\n\t\tif(!tagNamePattern.test(qName)){\r\n\t\t\tthrow new Error('invalid attribute:'+qName)\r\n\t\t}\r\n\t\tthis[this.length++] = {qName:qName,value:value,offset:offset}\r\n\t},\r\n\tlength:0,\r\n\tgetLocalName:function(i){return this[i].localName},\r\n\tgetOffset:function(i){return this[i].offset},\r\n\tgetQName:function(i){return this[i].qName},\r\n\tgetURI:function(i){return this[i].uri},\r\n\tgetValue:function(i){return this[i].value}\r\n//\t,getIndex:function(uri, localName)){\r\n//\t\tif(localName){\r\n//\t\t\t\r\n//\t\t}else{\r\n//\t\t\tvar qName = uri\r\n//\t\t}\r\n//\t},\r\n//\tgetValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\r\n//\tgetType:function(uri,localName){}\r\n//\tgetType:function(i){},\r\n}\r\n\r\n\r\n\r\n\r\nfunction _set_proto_(thiz,parent){\r\n\tthiz.__proto__ = parent;\r\n\treturn thiz;\r\n}\r\nif(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){\r\n\t_set_proto_ = function(thiz,parent){\r\n\t\tfunction p(){};\r\n\t\tp.prototype = parent;\r\n\t\tp = new p();\r\n\t\tfor(parent in thiz){\r\n\t\t\tp[parent] = thiz[parent];\r\n\t\t}\r\n\t\treturn p;\r\n\t}\r\n}\r\n\r\nfunction split(source,start){\r\n\tvar match;\r\n\tvar buf = [];\r\n\tvar reg = /'[^']+'|\"[^\"]+\"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;\r\n\treg.lastIndex = start;\r\n\treg.exec(source);//skip <\r\n\twhile(match = reg.exec(source)){\r\n\t\tbuf.push(match);\r\n\t\tif(match[1])return buf;\r\n\t}\r\n}\r\n\r\nif(typeof require == 'function'){\r\n\texports.XMLReader = XMLReader;\r\n}\r\n\r\n\n},{}],33:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"dav\",\n  \"version\": \"1.7.8\",\n  \"author\": \"Gareth Aye [:gaye] <gaye@mozilla.com>\",\n  \"description\": \"WebDAV, CalDAV, and CardDAV client for nodejs and the browser\",\n  \"license\": \"MPL-2.0\",\n  \"main\": \"./dav.js\",\n  \"repository\": \"https://github.com/gaye/dav\",\n  \"keywords\": [\n    \"address book\",\n    \"calendar\",\n    \"contacts\",\n    \"dav\",\n    \"caldav\",\n    \"carddav\",\n    \"webdav\",\n    \"ical\",\n    \"vcard\",\n    \"sync\",\n    \"rfc 4791\",\n    \"rfc 6352\",\n    \"rfc 6578\"\n  ],\n  \"dependencies\": {\n    \"co\": \"^4.6.0\",\n    \"xmldom\": \"^0.1.19\",\n    \"xmlhttprequest\": \"^1.7.0\"\n  },\n  \"devDependencies\": {\n    \"babel\": \"^5.8.23\",\n    \"browserify\": \"^11.0.1\",\n    \"chai\": \"^3.2.0\",\n    \"doctoc\": \"^0.15.0\",\n    \"mocha\": \"^2.3.2\",\n    \"nock\": \"^2.10.0\",\n    \"sinon\": \"^1.16.1\",\n    \"tcp-port-used\": \"^0.1.2\",\n    \"uglify-js\": \"^2.4.24\"\n  },\n  \"scripts\": {\n    \"test\": \"make test\"\n  }\n}\n\n},{}]},{},[8])(8)\n});","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/accounts.js":"import co from 'co';\nimport url from 'url';\n\nimport { listCalendars, listCalendarObjects } from './calendars';\nimport { listAddressBooks, listVCards } from './contacts';\nimport fuzzyUrlEquals from './fuzzy_url_equals';\nimport { Account } from './model';\nimport * as ns from './namespace';\nimport * as request from './request';\n\nlet debug = require('./debug')('dav:accounts');\n\nlet defaults = {\n  accountType: 'caldav',\n  loadCollections: true,\n  loadObjects: false\n};\n\n/**\n * rfc 6764.\n *\n * @param {dav.Account} account to find root url for.\n */\nlet serviceDiscovery = co.wrap(function *(account, options) {\n  debug('Attempt service discovery.');\n\n  let endpoint = url.parse(account.server);\n  endpoint.protocol = endpoint.protocol || 'http';  // TODO(gareth) https?\n\n  let uri = url.format({\n    protocol: endpoint.protocol,\n    host: endpoint.host,\n    pathname: `/.well-known/${options.accountType}`\n  });\n\n  let req = request.basic({ method: 'GET' });\n  try {\n    let xhr = yield options.xhr.send(req, uri, { sandbox: options.sandbox });\n    if (xhr.status >= 300 && xhr.status < 400) {\n      // http redirect.\n      let location = xhr.getResponseHeader('Location');\n      if (typeof location === 'string' && location.length) {\n        debug(`Discovery redirected to ${location}`);\n        return url.format({\n          protocol: endpoint.protocol,\n          host: endpoint.host,\n          pathname: location\n        });\n      }\n    }\n  } catch (error) {\n    debug('Discovery failed... failover to the provided url');\n  }\n\n  return endpoint.href;\n});\n\n/**\n * rfc 5397.\n *\n * @param {dav.Account} account to get principal url for.\n */\nlet principalUrl = co.wrap(function *(account, options) {\n  debug(`Fetch principal url from context path ${account.rootUrl}.`);\n  let req = request.propfind({\n    props: [ { name: 'current-user-principal', namespace: ns.DAV } ],\n    depth: 0,\n    mergeResponses: true\n  });\n\n  let res = yield options.xhr.send(req, account.rootUrl, {\n    sandbox: options.sandbox\n  });\n\n  let container = res.props;\n  debug(`Received principal: ${container.currentUserPrincipal}`);\n  return url.resolve(account.rootUrl, container.currentUserPrincipal);\n});\n\n/**\n * @param {dav.Account} account to get home url for.\n */\nlet homeUrl = co.wrap(function *(account, options) {\n  debug(`Fetch home url from principal url ${account.principalUrl}.`);\n  let prop;\n  if (options.accountType === 'caldav') {\n    prop = { name: 'calendar-home-set', namespace: ns.CALDAV };\n  } else if (options.accountType === 'carddav') {\n    prop = { name: 'addressbook-home-set', namespace: ns.CARDDAV };\n  }\n\n  var req = request.propfind({ props: [ prop ] });\n\n  let responses = yield options.xhr.send(req, account.principalUrl, {\n    sandbox: options.sandbox\n  });\n\n  let response = responses.find(response => {\n    return fuzzyUrlEquals(account.principalUrl, response.href);\n  });\n\n  let container = response.props;\n  let href;\n  if (options.accountType === 'caldav') {\n    debug(`Received home: ${container.calendarHomeSet}`);\n    href = container.calendarHomeSet;\n  } else if (options.accountType === 'carddav') {\n    debug(`Received home: ${container.addressbookHomeSet}`);\n    href = container.addressbookHomeSet;\n  }\n\n  return url.resolve(account.rootUrl, href);\n});\n\n/**\n * Options:\n *\n *   (String) accountType - one of 'caldav' or 'carddav'. Defaults to 'caldav'.\n *   (Array.<Object>) filters - list of caldav filters to send with request.\n *   (Boolean) loadCollections - whether or not to load dav collections.\n *   (Boolean) loadObjects - whether or not to load dav objects.\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (String) server - some url for server (needn't be base url).\n *   (String) timezone - VTIMEZONE calendar object.\n *   (dav.Transport) xhr - request sender.\n *\n * @return {Promise} a promise that will resolve with a dav.Account object.\n */\nexports.createAccount = co.wrap(function *(options) {\n  options = Object.assign({}, defaults, options);\n  if (typeof options.loadObjects !== 'boolean') {\n    options.loadObjects = options.loadCollections;\n  }\n\n  let account = new Account({\n    server: options.server,\n    credentials: options.xhr.credentials\n  });\n\n  account.rootUrl = yield serviceDiscovery(account, options);\n  account.principalUrl = yield principalUrl(account, options);\n  account.homeUrl = yield homeUrl(account, options);\n\n  if (!options.loadCollections) {\n    return account;\n  }\n\n  let key, loadCollections, loadObjects;\n  if (options.accountType === 'caldav') {\n    key = 'calendars';\n    loadCollections = listCalendars;\n    loadObjects = listCalendarObjects;\n  } else if (options.accountType === 'carddav') {\n    key = 'addressBooks';\n    loadCollections = listAddressBooks;\n    loadObjects = listVCards;\n  }\n\n  var collections = yield loadCollections(account, options);\n  account[key] = collections;\n  if (!options.loadObjects) {\n    return account;\n  }\n\n  yield collections.map(co.wrap(function *(collection) {\n    try {\n      collection.objects = yield loadObjects(collection, options);\n    } catch (error) {\n      collection.error = error;\n    }\n  }));\n\n  account[key] = account[key].filter(function(collection) {\n    return !collection.error;\n  });\n\n  return account;\n});\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/calendars.js":"import co from 'co';\nimport url from 'url';\n\nimport fuzzyUrlEquals from './fuzzy_url_equals';\nimport { Calendar, CalendarObject } from './model';\nimport * as ns from './namespace';\nimport * as request from './request';\nimport * as webdav from './webdav';\n\nlet debug = require('./debug')('dav:calendars');\n\nconst ICAL_OBJS = new Set([\n  'VEVENT',\n  'VTODO',\n  'VJOURNAL',\n  'VFREEBUSY',\n  'VTIMEZONE',\n  'VALARM'\n]);\n\n/**\n * @param {dav.Account} account to fetch calendars for.\n */\nexport let listCalendars = co.wrap(function *(account, options) {\n  debug(`Fetch calendars from home url ${account.homeUrl}`);\n  var req = request.propfind({\n    props: [\n      { name: 'calendar-description', namespace: ns.CALDAV },\n      { name: 'calendar-timezone', namespace: ns.CALDAV },\n      { name: 'displayname', namespace: ns.DAV },\n      { name: 'getctag', namespace: ns.CALENDAR_SERVER },\n      { name: 'resourcetype', namespace: ns.DAV },\n      { name: 'supported-calendar-component-set', namespace: ns.CALDAV },\n      { name: 'sync-token', namespace: ns.DAV }\n    ],\n    depth: 1\n  });\n\n  let responses = yield options.xhr.send(req, account.homeUrl, {\n    sandbox: options.sandbox\n  });\n\n  debug(`Found ${responses.length} calendars.`);\n  let cals = responses\n    .filter(res => {\n      // We only want the calendar if it contains iCalendar objects.\n      let components = res.props.supportedCalendarComponentSet || [];\n      return components.reduce((hasObjs, component) => {\n          return hasObjs || ICAL_OBJS.has(component)\n      }, false)\n    })\n    .map(res => {\n      debug(`Found calendar ${res.props.displayname},\n             props: ${JSON.stringify(res.props)}`);\n      return new Calendar({\n        data: res,\n        account: account,\n        description: res.props.calendarDescription,\n        timezone: res.props.calendarTimezone,\n        url: url.resolve(account.rootUrl, res.href),\n        ctag: res.props.getctag,\n        displayName: res.props.displayname,\n        components: res.props.supportedCalendarComponentSet,\n        resourcetype: res.props.resourcetype,\n        syncToken: res.props.syncToken\n      });\n    });\n\n  yield cals.map(co.wrap(function *(cal) {\n    cal.reports = yield webdav.supportedReportSet(cal, options);\n  }));\n\n  return cals;\n});\n\n/**\n * @param {dav.Calendar} calendar the calendar to put the object on.\n * @return {Promise} promise will resolve when the calendar has been created.\n *\n * Options:\n *\n *   (String) data - rfc 5545 VCALENDAR object.\n *   (String) filename - name for the calendar ics file.\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\nexport function createCalendarObject(calendar, options) {\n  var objectUrl = url.resolve(calendar.url, options.filename);\n  return webdav.createObject(objectUrl, options.data, options);\n};\n\n/**\n * @param {dav.CalendarObject} calendarObject updated calendar object.\n * @return {Promise} promise will resolve when the calendar has been updated.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\nexport function updateCalendarObject(calendarObject, options) {\n  return webdav.updateObject(\n    calendarObject.url,\n    calendarObject.calendarData,\n    calendarObject.etag,\n    options\n  );\n}\n\n/**\n * @param {dav.CalendarObject} calendarObject target calendar object.\n * @return {Promise} promise will resolve when the calendar has been deleted.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\nexport function deleteCalendarObject(calendarObject, options) {\n  return webdav.deleteObject(\n    calendarObject.url,\n    calendarObject.etag,\n    options\n  );\n}\n\n/**\n * @param {dav.Calendar} calendar the calendar to fetch objects for.\n *\n * Options:\n *\n *   (Array.<Object>) filters - optional caldav filters.\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\nexport let listCalendarObjects = co.wrap(function *(calendar, options) {\n  debug(`Doing REPORT on calendar ${calendar.url} which belongs to\n         ${calendar.account.credentials.username}`);\n\n  let filters = options.filters || [{\n    type: 'comp-filter',\n    attrs: { name: 'VCALENDAR' },\n    children: [{\n      type: 'comp-filter',\n      attrs: { name: 'VEVENT' }\n    }]\n  }];\n\n  let req = request.calendarQuery({\n    depth: 1,\n    props: [\n      { name: 'getetag', namespace: ns.DAV },\n      { name: 'calendar-data', namespace: ns.CALDAV }\n    ],\n    filters: filters\n  });\n\n  let responses = yield options.xhr.send(req, calendar.url, {\n    sandbox: options.sandbox\n  });\n\n  return responses.map(res => {\n    debug(`Found calendar object with url ${res.href}`);\n    return new CalendarObject({\n      data: res,\n      calendar: calendar,\n      url: url.resolve(calendar.account.rootUrl, res.href),\n      etag: res.props.getetag,\n      calendarData: res.props.calendarData\n    });\n  });\n});\n\n/**\n * @param {dav.Calendar} calendar the calendar to fetch updates to.\n * @return {Promise} promise will resolve with updated calendar object.\n *\n * Options:\n *\n *   (Array.<Object>) filters - list of caldav filters to send with request.\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (String) syncMethod - either 'basic' or 'webdav'. If unspecified, will\n *       try to do webdav sync and failover to basic sync if rfc 6578 is not\n *       supported by the server.\n *   (String) timezone - VTIMEZONE calendar object.\n *   (dav.Transport) xhr - request sender.\n */\nexport function syncCalendar(calendar, options) {\n  options.basicSync = basicSync;\n  options.webdavSync = webdavSync;\n  return webdav.syncCollection(calendar, options);\n}\n\n/**\n * @param {dav.Account} account the account to fetch updates for.\n * @return {Promise} promise will resolve with updated account.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\nexport let syncCaldavAccount = co.wrap(function *(account, options={}) {\n  options.loadObjects = false;\n  if (!account.calendars) account.calendars = [];\n\n  let cals = yield listCalendars(account, options);\n  cals\n    .filter(cal => {\n      // Filter the calendars not previously seen.\n      return account.calendars.every(prev => !fuzzyUrlEquals(prev.url, cal.url));\n    })\n    .forEach(cal => {\n      // Add them to the account's calendar list.\n      account.calendars.push(cal);\n    });\n\n  options.loadObjects = true;\n  yield account.calendars.map(co.wrap(function *(cal, index) {\n    try {\n      yield syncCalendar(cal, options);\n    } catch (error) {\n      debug(`Sync calendar ${cal.displayName} failed with ${error}`);\n      account.calendars.splice(index, 1);\n    }\n  }));\n\n  return account;\n});\n\nlet basicSync = co.wrap(function *(calendar, options) {\n  let sync = yield webdav.isCollectionDirty(calendar, options);\n  if (!sync) {\n    debug('Local ctag matched remote! No need to sync :).');\n    return calendar;\n  }\n\n  debug('ctag changed so we need to fetch stuffs.');\n  calendar.objects = yield listCalendarObjects(calendar, options);\n  return calendar;\n});\n\nlet webdavSync = co.wrap(function *(calendar, options) {\n  var req = request.syncCollection({\n    props: [\n      { name: 'getetag', namespace: ns.DAV },\n      { name: 'calendar-data', namespace: ns.CALDAV }\n    ],\n    syncLevel: 1,\n    syncToken: calendar.syncToken\n  });\n\n  let result = yield options.xhr.send(req, calendar.url, {\n    sandbox: options.sandbox\n  });\n\n  // TODO(gareth): Handle creations and deletions.\n  result.responses.forEach(function(response) {\n    // Find the calendar object that this response corresponds with.\n    var calendarObject = calendar.objects.filter(function(object) {\n      return fuzzyUrlEquals(object.url, response.href);\n    })[0];\n\n    if (!calendarObject) {\n      return;\n    }\n\n    calendarObject.etag = response.props.getetag;\n    calendarObject.calendarData = response.props.calendarData;\n  });\n\n  calendar.syncToken = result.syncToken;\n  return calendar;\n});\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/camelize.js":"/**\n * @fileoverview Camelcase something.\n */\nexport default function camelize(str, delimiter='_') {\n  let words = str.split(delimiter);\n  return [words[0]]\n    .concat(\n      words.slice(1).map(word => word.charAt(0).toUpperCase() + word.slice(1))\n    )\n    .join('');\n}\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/client.js":"import url from 'url';\n\nimport * as accounts from './accounts';\nimport * as calendars from './calendars';\nimport * as contacts from './contacts';\n\n/**\n * @param {dav.Transport} xhr - request sender.\n *\n * Options:\n *\n *   (String) baseUrl - root url to resolve relative request urls with.\n */\nexport class Client {\n  constructor(xhr, options={}) {\n    this.xhr = xhr;\n    Object.assign(this, options);\n\n    // Expose internal modules for unit testing\n    this._accounts = accounts;\n    this._calendars = calendars;\n    this._contacts = contacts;\n  }\n\n  /**\n   * @param {dav.Request} req - dav request.\n   * @param {String} uri - where to send request.\n   * @return {Promise} a promise that will be resolved with an xhr request\n   *     after its readyState is 4 or the result of applying an optional\n   *     request `transformResponse` function to the xhr object after its\n   *     readyState is 4.\n   *\n   * Options:\n   *\n   *   (Object) sandbox - optional request sandbox.\n   */\n  send(req, uri, options) {\n    if (this.baseUrl) {\n      let urlObj = url.parse(uri);\n      uri = url.resolve(this.baseUrl, urlObj.path);\n    }\n\n    return this.xhr.send(req, uri, options);\n  }\n\n  createAccount(options={}) {\n    options.xhr = options.xhr || this.xhr;\n    return accounts.createAccount(options);\n  }\n\n  createCalendarObject(calendar, options={}) {\n    options.xhr = options.xhr || this.xhr;\n    return calendars.createCalendarObject(calendar, options);\n  }\n\n  updateCalendarObject(calendarObject, options={}) {\n    options.xhr = options.xhr || this.xhr;\n    return calendars.updateCalendarObject(calendarObject, options);\n  }\n\n  deleteCalendarObject(calendarObject, options={}) {\n    options.xhr = options.xhr || this.xhr;\n    return calendars.deleteCalendarObject(calendarObject, options);\n  }\n\n  syncCalendar(calendar, options={}) {\n    options.xhr = options.xhr || this.xhr;\n    return calendars.syncCalendar(calendar, options);\n  }\n\n  syncCaldavAccount(account, options={}) {\n    options.xhr = options.xhr || this.xhr;\n    return calendars.syncCaldavAccount(account, options);\n  }\n\n  createCard(addressBook, options={}) {\n    options.xhr = options.xhr || this.xhr;\n    return contacts.createCard(addressBook, options);\n  }\n\n  updateCard(card, options={}) {\n    options.xhr = options.xhr || this.xhr;\n    return contacts.updateCard(card, options);\n  }\n\n  deleteCard(card, options={}) {\n    options.xhr = options.xhr || this.xhr;\n    return contacts.deleteCard(card, options);\n  }\n\n  syncAddressBook(addressBook, options={}) {\n    options.xhr = options.xhr || this.xhr;\n    return contacts.syncAddressBook(addressBook, options);\n  }\n\n  syncCarddavAccount(account, options={}) {\n    options.xhr = options.xhr || this.xhr;\n    return contacts.syncCarddavAccount(account, options);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/contacts.js":"import co from 'co';\nimport url from 'url';\n\nimport fuzzyUrlEquals from './fuzzy_url_equals';\nimport { AddressBook, VCard } from './model';\nimport * as ns from './namespace';\nimport * as request from './request';\nimport * as webdav from './webdav';\n\nlet debug = require('./debug')('dav:contacts');\n\n/**\n * @param {dav.Account} account to fetch address books for.\n */\nexport let listAddressBooks = co.wrap(function *(account, options) {\n  debug(`Fetch address books from home url ${account.homeUrl}`);\n  var req = request.propfind({\n    props: [\n      { name: 'displayname', namespace: ns.DAV },\n      { name: 'getctag', namespace: ns.CALENDAR_SERVER },\n      { name: 'resourcetype', namespace: ns.DAV },\n      { name: 'sync-token', namespace: ns.DAV }\n    ],\n    depth: 1\n  });\n\n  let responses = yield options.xhr.send(req, account.homeUrl, {\n    sandbox: options.sandbox\n  });\n\n  let addressBooks = responses\n    .filter(res => {\n      return typeof res.props.displayname === 'string';\n    })\n    .map(res => {\n      debug(`Found address book named ${res.props.displayname},\n             props: ${JSON.stringify(res.props)}`);\n      return new AddressBook({\n        data: res,\n        account: account,\n        url: url.resolve(account.rootUrl, res.href),\n        ctag: res.props.getctag,\n        displayName: res.props.displayname,\n        resourcetype: res.props.resourcetype,\n        syncToken: res.props.syncToken\n      });\n    });\n\n  yield addressBooks.map(co.wrap(function *(addressBook) {\n    addressBook.reports = yield webdav.supportedReportSet(addressBook, options);\n  }));\n\n  return addressBooks;\n});\n\n/**\n * @param {dav.AddressBook} addressBook the address book to put the object on.\n * @return {Promise} promise will resolve when the card has been created.\n *\n * Options:\n *\n *   (String) data - vcard object.\n *   (String) filename - name for the address book vcf file.\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\nexport function createCard(addressBook, options) {\n  let objectUrl = url.resolve(addressBook.url, options.filename);\n  return webdav.createObject(objectUrl, options.data, options);\n}\n\n/**\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n */\nexport let listVCards = co.wrap(function *(addressBook, options) {\n  debug(`Doing REPORT on address book ${addressBook.url} which belongs to\n        ${addressBook.account.credentials.username}`);\n\n  var req = request.addressBookQuery({\n    depth: 1,\n    props: [\n      { name: 'getetag', namespace: ns.DAV },\n      { name: 'address-data', namespace: ns.CARDDAV }\n    ]\n  });\n\n  let responses = yield options.xhr.send(req, addressBook.url, {\n    sandbox: options.sandbox\n  });\n\n  return responses.map(res => {\n    debug(`Found vcard with url ${res.href}`);\n    return new VCard({\n      data: res,\n      addressBook: addressBook,\n      url: url.resolve(addressBook.account.rootUrl, res.href),\n      etag: res.props.getetag,\n      addressData: res.props.addressData\n    });\n  });\n});\n\n/**\n * @param {dav.VCard} card updated vcard object.\n * @return {Promise} promise will resolve when the card has been updated.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\nexport function updateCard(card, options) {\n  return webdav.updateObject(\n    card.url,\n    card.addressData,\n    card.etag,\n    options\n  );\n}\n\n/**\n * @param {dav.VCard} card target vcard object.\n * @return {Promise} promise will resolve when the calendar has been deleted.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\nexport function deleteCard(card, options) {\n  return webdav.deleteObject(\n    card.url,\n    card.etag,\n    options\n  );\n}\n\n/**\n * @param {dav.Calendar} calendar the calendar to fetch updates to.\n * @return {Promise} promise will resolve with updated calendar object.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (String) syncMethod - either 'basic' or 'webdav'. If unspecified, will\n *       try to do webdav sync and failover to basic sync if rfc 6578 is not\n *       supported by the server.\n *   (dav.Transport) xhr - request sender.\n */\nexport function syncAddressBook(addressBook, options) {\n  options.basicSync = basicSync;\n  options.webdavSync = webdavSync;\n  return webdav.syncCollection(addressBook, options);\n}\n\n/**\n * @param {dav.Account} account the account to fetch updates for.\n * @return {Promise} promise will resolve with updated account.\n *\n * Options:\n *\n *   (dav.Sandbox) sandbox - optional request sandbox.\n *   (dav.Transport) xhr - request sender.\n */\nexport let syncCarddavAccount = co.wrap(function *(account, options={}) {\n  options.loadObjects = false;\n\n  if (!account.addressBooks) {\n    account.addressBooks = [];\n  }\n\n  let addressBooks = yield listAddressBooks(account, options);\n  addressBooks\n    .filter(function(addressBook) {\n      // Filter the address books not previously seen.\n      return account.addressBooks.every(\n        prev => !fuzzyUrlEquals(prev.url, addressBook.url)\n      );\n    })\n    .forEach(addressBook => account.addressBooks.push(addressBook));\n\n  options.loadObjects = true;\n  yield account.addressBooks.map(co.wrap(function *(addressBook, index) {\n    try {\n      yield syncAddressBook(addressBook, options);\n    } catch (error) {\n      debug(`Syncing ${addressBook.displayName} failed with ${error}`);\n      account.addressBooks.splice(index, 1);\n    }\n  }));\n\n  return account;\n});\n\nlet basicSync = co.wrap(function *(addressBook, options) {\n  let sync = webdav.isCollectionDirty(addressBook, options)\n  if (!sync) {\n    debug('Local ctag matched remote! No need to sync :).');\n    return addressBook;\n  }\n\n  debug('ctag changed so we need to fetch stuffs.');\n  addressBook.objects = yield listVCards(addressBook, options);\n  return addressBook;\n});\n\nlet webdavSync = co.wrap(function *(addressBook, options) {\n  var req = request.syncCollection({\n    props: [\n      { name: 'getetag', namespace: ns.DAV },\n      { name: 'address-data', namespace: ns.CARDDAV }\n    ],\n    syncLevel: 1,\n    syncToken: addressBook.syncToken\n  });\n\n  let result = yield options.xhr.send(req, addressBook.url, {\n    sandbox: options.sandbox\n  });\n\n  // TODO(gareth): Handle creations and deletions.\n  result.responses.forEach(response => {\n    // Find the vcard that this response corresponds with.\n    let vcard = addressBook.objects.filter(object => {\n      return fuzzyUrlEquals(object.url, response.href);\n    })[0];\n\n    if (!vcard) return;\n\n    vcard.etag = response.props.getetag;\n    vcard.addressData = response.props.addressData;\n  });\n\n  addressBook.syncToken = result.syncToken;\n  return addressBook;\n});\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/debug.js":"export default function debug(topic) {\n  return function(message) {\n    if (debug.enabled) {\n      console.log(`[${topic}] ${message}`);\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/fuzzy_url_equals.js":"'use strict';\nexport default function fuzzyUrlEquals(one, other) {\n  return fuzzyIncludes(one, other) || fuzzyIncludes(other, one);\n};\n\nfunction fuzzyIncludes(one, other) {\n  return one.indexOf(other) !== -1 ||\n         (other.charAt(other.length -1) === '/' &&\n          one.indexOf(other.slice(0, -1)) !== -1);\n}\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/model.js":"export class Account {\n  constructor(options) {\n    Object.assign(this, {\n      server: null,\n      credentials: null,\n      rootUrl: null,\n      principalUrl: null,\n      homeUrl: null,\n      calendars: null,\n      addressBooks: null\n    }, options);\n  }\n}\n\n/**\n * Options:\n *   (String) username - username (perhaps email) for calendar user.\n *   (String) password - plaintext password for calendar user.\n *   (String) clientId - oauth client id.\n *   (String) clientSecret - oauth client secret.\n *   (String) authorizationCode - oauth code.\n *   (String) redirectUrl - oauth redirect url.\n *   (String) tokenUrl - oauth token url.\n *   (String) accessToken - oauth access token.\n *   (String) refreshToken - oauth refresh token.\n *   (Number) expiration - unix time for access token expiration.\n */\nexport class Credentials {\n  constructor(options) {\n    Object.assign(this, {\n      username: null,\n      password: null,\n      clientId: null,\n      clientSecret: null,\n      authorizationCode: null,\n      redirectUrl: null,\n      tokenUrl: null,\n      accessToken: null,\n      refreshToken: null,\n      expiration: null\n    }, options);\n  }\n}\n\nexport class DAVCollection {\n  constructor(options) {\n    Object.assign(this, {\n      data: null,\n      objects: null,\n      account: null,\n      ctag: null,\n      description: null,\n      displayName: null,\n      reports: null,\n      resourcetype: null,\n      syncToken: null,\n      url: null\n    }, options);\n  }\n}\n\nexport class AddressBook extends DAVCollection {\n  constructor(options) {\n    super(options);\n  }\n}\n\nexport class Calendar extends DAVCollection {\n  constructor(options) {\n    super(options);\n    Object.assign(this, {\n      components: null,\n      timezone: null\n    }, options);\n  }\n}\n\nexport class DAVObject {\n  constructor(options) {\n    Object.assign(this, {\n      data: null,\n      etag: null,\n      url: null\n    }, options);\n  }\n}\n\nexport class CalendarObject extends DAVObject {\n  constructor(options) {\n    super(options);\n    Object.assign(this, {\n      calendar: null,\n      calendarData: null\n    }, options);\n  }\n}\n\nexport class VCard extends DAVObject {\n  constructor(options) {\n    super(options);\n    Object.assign(this, {\n      addressBook: null,\n      addressData: null\n    }, options);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/namespace.js":"export const CALENDAR_SERVER = 'http://calendarserver.org/ns/';\nexport const CALDAV = 'urn:ietf:params:xml:ns:caldav';\nexport const CARDDAV = 'urn:ietf:params:xml:ns:carddav';\nexport const DAV = 'DAV:';\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/parser.js":"import camelize from './camelize';\n\nlet debug = require('./debug')('dav:parser');\n\nlet DOMParser;\nif (typeof self !== 'undefined' && 'DOMParser' in self) {\n  // browser main thread\n  DOMParser = self.DOMParser;\n} else {\n  // nodejs or web worker\n  DOMParser = require('xmldom').DOMParser;\n}\n\nexport function multistatus(string) {\n  let parser = new DOMParser();\n  let doc = parser.parseFromString(string, 'text/xml');\n  let result = traverse.multistatus(child(doc, 'multistatus'));\n  debug(`input:\\n${string}\\noutput:\\n${JSON.stringify(result)}\\n`);\n  return result;\n}\n\nlet traverse = {\n  // { response: [x, y, z] }\n  multistatus: node => complex(node, { response: true }),\n\n  // { propstat: [x, y, z] }\n  response: node => complex(node, { propstat: true, href: false }),\n\n  // { prop: x }\n  propstat: node => complex(node, { prop: false }),\n\n  // {\n  //   resourcetype: x\n  //   supportedCalendarComponentSet: y,\n  //   supportedReportSet: z\n  // }\n  prop: node => {\n    return complex(node, {\n      resourcetype: false,\n      supportedCalendarComponentSet: false,\n      supportedReportSet: false,\n      currentUserPrincipal: false\n    });\n  },\n\n  resourcetype: node => {\n    return childNodes(node).map(childNode => childNode.localName);\n  },\n\n  // [x, y, z]\n  supportedCalendarComponentSet: node => complex(node, { comp: true }, 'comp'),\n\n  // [x, y, z]\n  supportedReportSet: node => {\n    return complex(node, { supportedReport: true }, 'supportedReport');\n  },\n\n  comp: node => node.getAttribute('name'),\n\n  // x\n  supportedReport: node => complex(node, { report: false }, 'report'),\n\n  report: node => {\n    return childNodes(node).map(childNode => childNode.localName);\n  },\n\n  href: node => {\n    return decodeURIComponent(childNodes(node)[0].nodeValue);\n  },\n\n  currentUserPrincipal: node => {\n    return complex(node, {href: false}, 'href');\n  }\n};\n\nfunction complex(node, childspec, collapse) {\n  let result = {};\n  for (let key in childspec) {\n    if (childspec[key]) {\n      // Create array since we're expecting multiple.\n      result[key] = [];\n    }\n  }\n\n  childNodes(node).forEach(\n    childNode => traverseChild(node, childNode, childspec, result)\n  );\n\n  return maybeCollapse(result, childspec, collapse);\n}\n\n/**\n * Parse child childNode of node with childspec and write outcome to result.\n */\nfunction traverseChild(node, childNode, childspec, result) {\n  if (childNode.nodeType === 3 && /^\\s+$/.test(childNode.nodeValue)) {\n    // Whitespace... nothing to do.\n    return;\n  }\n\n  let localName = camelize(childNode.localName, '-');\n  if (!(localName in childspec)) {\n    debug('Unexpected node of type ' + localName + ' encountered while ' +\n          'parsing ' + node.localName + ' node!');\n    let value = childNode.textContent;\n    if (localName in result) {\n      if (!Array.isArray(result[camelCase])) {\n        // Since we've already encountered this node type and we haven't yet\n        // made an array for it, make an array now.\n        result[localName] = [result[localName]];\n      }\n\n      result[localName].push(value);\n      return;\n    }\n\n    // First time we're encountering this node.\n    result[localName] = value;\n    return;\n  }\n\n  let traversal = traverse[localName](childNode);\n  if (childspec[localName]) {\n    // Expect multiple.\n    result[localName].push(traversal);\n  } else {\n    // Expect single.\n    result[localName] = traversal;\n  }\n}\n\nfunction maybeCollapse(result, childspec, collapse) {\n  if (!collapse) {\n    return result;\n  }\n\n  if (!childspec[collapse]) {\n    return result[collapse];\n  }\n\n  // Collapse array.\n  return result[collapse].reduce((a, b) => a.concat(b), []);\n}\n\nfunction childNodes(node) {\n  let result = node.childNodes;\n  if (!Array.isArray(result)) {\n    result = Array.prototype.slice.call(result);\n  }\n\n  return result;\n}\n\nfunction children(node, localName) {\n  return childNodes(node).filter(childNode => childNode.localName === localName);\n}\n\nfunction child(node, localName) {\n  return children(node, localName)[0];\n}\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/request.js":"import { multistatus } from './parser';\nimport * as template from './template';\n\n/**\n * Options:\n *\n *   (String) depth - optional value for Depth header.\n *   (Array.<Object>) props - list of props to request.\n */\nexport function addressBookQuery(options) {\n  return collectionQuery(\n    template.addressBookQuery({ props: options.props || [] }),\n    { depth: options.depth }\n  );\n}\n\n/**\n * Options:\n *\n *   (String) data - put request body.\n *   (String) method - http method.\n *   (String) etag - cached calendar object etag.\n */\nexport function basic(options) {\n  function transformRequest(xhr) {\n    setRequestHeaders(xhr, options);\n  }\n\n  return new Request({\n    method: options.method,\n    requestData: options.data,\n    transformRequest: transformRequest\n  });\n}\n\n/**\n * Options:\n *\n *   (String) depth - optional value for Depth header.\n *   (Array.<Object>) filters - list of filters to send with request.\n *   (Array.<Object>) props - list of props to request.\n *   (String) timezone - VTIMEZONE calendar object.\n */\nexport function calendarQuery(options) {\n  return collectionQuery(\n    template.calendarQuery({\n      props: options.props || [],\n      filters: options.filters || [],\n      timezone: options.timezone\n    }),\n    {\n      depth: options.depth\n    }\n  );\n}\n\nexport function collectionQuery(requestData, options) {\n  function transformRequest(xhr) {\n    setRequestHeaders(xhr, options);\n  }\n\n  function transformResponse(xhr) {\n    return multistatus(xhr.responseText).response.map(res => {\n      return { href: res.href, props: getProps(res.propstat) };\n    });\n  }\n\n  return new Request({\n    method: 'REPORT',\n    requestData: requestData,\n    transformRequest: transformRequest,\n    transformResponse: transformResponse\n  });\n}\n\n/**\n * Options:\n *\n *   (String) depth - optional value for Depth header.\n *   (Array.<Object>) props - list of props to request.\n */\nexport function propfind(options) {\n  let requestData = template.propfind({ props: options.props });\n\n  function transformRequest(xhr) {\n    setRequestHeaders(xhr, options);\n  }\n\n  function transformResponse(xhr) {\n    let responses = multistatus(xhr.responseText).response.map(res => {\n      return { href: res.href, props: getProps(res.propstat) };\n    });\n\n    if (!options.mergeResponses) {\n      return responses;\n    }\n\n    // Merge the props.\n    let merged = mergeProps(responses.map(res => res.props));\n    let hrefs = responses.map(res => res.href);\n    return { props: merged, hrefs: hrefs };\n  }\n\n  return new Request({\n    method: 'PROPFIND',\n    requestData: requestData,\n    transformRequest: transformRequest,\n    transformResponse: transformResponse\n  });\n}\n\n/**\n * Options:\n *\n *   (String) depth - option value for Depth header.\n *   (Array.<Object>) props - list of props to request.\n *   (Number) syncLevel - indicates scope of the sync report request.\n *   (String) syncToken - synchronization token provided by the server.\n */\nexport function syncCollection(options) {\n  let requestData = template.syncCollection({\n    props: options.props,\n    syncLevel: options.syncLevel,\n    syncToken: options.syncToken\n  });\n\n  function transformRequest(xhr) {\n    setRequestHeaders(xhr, options);\n  }\n\n  function transformResponse(xhr) {\n    let object = multistatus(xhr.responseText);\n    let responses = object.response.map(res => {\n      return { href: res.href, props: getProps(res.propstat) };\n    });\n\n    return { responses: responses, syncToken: object.syncToken };\n  }\n\n  return new Request({\n    method: 'REPORT',\n    requestData: requestData,\n    transformRequest: transformRequest,\n    transformResponse: transformResponse\n  });\n}\n\nexport class Request {\n  constructor(options={}) {\n    Object.assign(this, {\n      method: null,\n      requestData: null,\n      transformRequest: null,\n      transformResponse: null,\n      onerror: null\n    }, options);\n  }\n}\n\nfunction getProp(propstat) {\n  if (/404/g.test(propstat.status)) {\n    return null;\n  }\n  if (/5\\d{2}/g.test(propstat.status) ||\n      /4\\d{2}/g.test(propstat.status)) {\n    throw new Error('Bad status on propstat: ' + propstat.status);\n  }\n\n  return ('prop' in propstat) ? propstat.prop : null;\n}\n\nexport function mergeProps(props) {\n  return props.reduce((a, b) => Object.assign(a, b), {});\n}\n\n/**\n * Map propstats to props.\n */\nexport function getProps(propstats) {\n  return mergeProps(\n    propstats\n      .map(getProp)\n      .filter(prop => prop && typeof prop === 'object')\n  );\n}\n\nexport function setRequestHeaders(request, options) {\n  request.setRequestHeader('Content-Type', 'application/xml;charset=utf-8');\n\n  if ('depth' in options) {\n    request.setRequestHeader('Depth', options.depth);\n  }\n\n  if ('etag' in options) {\n    request.setRequestHeader('If-Match', options.etag);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/sandbox.js":"/**\n * @fileoverview Group requests together and then abort as a group.\n *\n * var sandbox = new dav.Sandbox();\n * return Promise.all([\n *   dav.createEvent(event, { sandbox: sandbox }),\n *   dav.deleteEvent(other, { sandbox: sandbox })\n * ])\n * .catch(function() {\n *   // Something went wrong so abort all requests.\n *   sandbox.abort;\n * });\n */\nlet debug = require('./debug')('dav:sandbox');\n\nexport class Sandbox {\n  constructor() {\n    this.requestList = [];\n  }\n\n  add(request) {\n    debug('Adding request to sandbox.');\n    this.requestList.push(request);\n  }\n\n  abort() {\n    debug('Aborting sandboxed requests.');\n    this.requestList.forEach(request => request.abort());\n  }\n}\n\nexport function createSandbox() {\n  return new Sandbox();\n}\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/transport.js":"import co from 'co';\nimport querystring from 'querystring';\n\nimport XMLHttpRequest from './xmlhttprequest';\n\nexport class Transport {\n  /**\n   * @param {dav.Credentials} credentials user authorization.\n   */\n  constructor(credentials) {\n    this.credentials = credentials || null;\n  }\n\n  /**\n   * @param {dav.Request} request object with request info.\n   * @return {Promise} a promise that will be resolved with an xhr request after\n   *     its readyState is 4 or the result of applying an optional request\n   *     `transformResponse` function to the xhr object after its readyState is 4.\n   *\n   * Options:\n   *\n   *   (Object) sandbox - optional request sandbox.\n   */\n  send() {}\n}\n\nexport class Basic extends Transport {\n  /**\n   * @param {dav.Credentials} credentials user authorization.\n   */\n  constructor(credentials) {\n    super(credentials);\n  }\n\n  send(request, url, options) {\n    return co(function *() {\n      let sandbox = options && options.sandbox;\n      let transformRequest = request.transformRequest;\n      let transformResponse = request.transformResponse;\n      let onerror = request.onerror;\n\n      let xhr = new XMLHttpRequest();\n      if (sandbox) sandbox.add(xhr);\n      xhr.open(\n        request.method,\n        url,\n        true /* async */,\n        this.credentials.username,\n        this.credentials.password\n      );\n\n      if (transformRequest) transformRequest(xhr);\n\n      let result;\n      try {\n        yield xhr.send(request.requestData);\n        result = transformResponse ? transformResponse(xhr) : xhr;\n      } catch (error) {\n        if (onerror) onerror(error);\n        throw error;\n      }\n\n      return result;\n    }.bind(this));\n  }\n}\n\n/**\n * @param {dav.Credentials} credentials user authorization.\n */\nexport class OAuth2 extends Transport {\n  constructor(credentials) {\n    super(credentials);\n  }\n\n  send(request, url, options={}) {\n    return co(function *() {\n      let sandbox = options.sandbox;\n      let transformRequest = request.transformRequest;\n      let transformResponse = request.transformResponse;\n      let onerror = request.onerror;\n\n      if (!('retry' in options)) options.retry = true;\n\n      let result, xhr;\n      try {\n        let token = yield access(this.credentials, options);\n        xhr = new XMLHttpRequest();\n        if (sandbox) sandbox.add(xhr);\n        xhr.open(request.method, url, true /* async */);\n        xhr.setRequestHeader('Authorization', `Bearer ${token}`);\n        if (transformRequest) transformRequest(xhr);\n        yield xhr.send(request.requestData);\n        result = transformResponse ? transformResponse(xhr) : xhr;\n      } catch (error) {\n        if (options.retry && xhr.status === 401) {\n          // Force expiration.\n          this.credentials.expiration = 0;\n          // Retry once at most.\n          options.retry = false;\n          return this.send(request, url, options);\n        }\n\n        if (onerror) onerror(error);\n        throw error;\n      }\n\n      return result;\n    }.bind(this));\n  }\n}\n\n/**\n * @return {Promise} promise that will resolve with access token.\n */\nfunction access(credentials, options) {\n  if (!credentials.accessToken) {\n    return getAccessToken(credentials, options);\n  }\n\n  if (credentials.refreshToken && isExpired(credentials)) {\n    return refreshAccessToken(credentials, options);\n  }\n\n  return Promise.resolve(credentials.accessToken);\n}\n\nfunction isExpired(credentials) {\n  return typeof credentials.expiration === 'number' &&\n         Date.now() > credentials.expiration;\n}\n\nlet getAccessToken = co.wrap(function *(credentials, options) {\n  let sandbox = options.sandbox;\n  let xhr = new XMLHttpRequest();\n  if (sandbox) sandbox.add(xhr);\n  xhr.open('POST', credentials.tokenUrl, true /* async */);\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\n  let data = querystring.stringify({\n    code: credentials.authorizationCode,\n    redirect_uri: credentials.redirectUrl,\n    client_id: credentials.clientId,\n    client_secret: credentials.clientSecret,\n    grant_type: 'authorization_code'\n  });\n\n  let now = Date.now();\n  yield xhr.send(data);\n  let response = JSON.parse(xhr.responseText);\n  credentials.accessToken = response.access_token;\n  credentials.refreshToken = 'refresh_token' in response ?\n    response.refresh_token :\n    null;\n  credentials.expiration = 'expires_in' in response ?\n    now + response.expires_in :\n    null;\n\n  return response.access_token;\n});\n\nlet refreshAccessToken = co.wrap(function *(credentials, options) {\n  let sandbox = options.sandbox;\n  let xhr = new XMLHttpRequest();\n  if (sandbox) sandbox.add(xhr);\n  xhr.open('POST', credentials.tokenUrl, true /* async */);\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\n  let data = querystring.stringify({\n    client_id: credentials.clientId,\n    client_secret: credentials.clientSecret,\n    refresh_token: credentials.refreshToken,\n    grant_type: 'refresh_token'\n  });\n\n  let now = Date.now();\n  yield xhr.send(data);\n  let response = JSON.parse(xhr.responseText);\n  credentials.accessToken = response.access_token;\n  credentials.expiration = 'expires_in' in response ?\n    now + response.expires_in :\n    null;\n\n  return response.access_token;\n});\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/webdav.js":"import co from 'co';\n\nimport fuzzyUrlEquals from './fuzzy_url_equals';\nimport * as ns from './namespace';\nimport * as request from './request';\n\nlet debug = require('./debug')('dav:webdav');\n\n/**\n * @param {String} objectUrl url for webdav object.\n * @param {String} objectData webdav object data.\n */\nexport function createObject(objectUrl, objectData, options) {\n  var req = request.basic({ method: 'PUT', data: objectData });\n  return options.xhr.send(req, objectUrl, { sandbox: options.sandbox });\n}\n\nexport function updateObject(objectUrl, objectData, etag, options) {\n  var req = request.basic({ method: 'PUT', data: objectData, etag: etag });\n  return options.xhr.send(req, objectUrl, { sandbox: options.sandbox });\n}\n\nexport function deleteObject(objectUrl, etag, options) {\n  var req = request.basic({ method: 'DELETE', etag: etag });\n  return options.xhr.send(req, objectUrl, { sandbox: options.sandbox });\n}\n\nexport function syncCollection(collection, options) {\n  let syncMethod;\n  if ('syncMethod' in options) {\n    syncMethod = options.syncMethod;\n  } else if (collection.reports &&\n             collection.reports.indexOf('syncCollection') !== -1) {\n    syncMethod = 'webdav';\n  } else {\n    syncMethod = 'basic';\n  }\n\n  if (syncMethod === 'webdav') {\n    debug('rfc 6578 sync.');\n    return options.webdavSync(collection, options);\n  } else {\n    debug('basic sync.');\n    return options.basicSync(collection, options);\n  }\n}\n\n/**\n * @param {dav.DAVCollection} collection to fetch report set for.\n */\nexport let supportedReportSet = co.wrap(function *(collection, options) {\n  debug('Checking supported report set for collection at ' + collection.url);\n  var req = request.propfind({\n    props: [ { name: 'supported-report-set', namespace: ns.DAV } ],\n    depth: 1,\n    mergeResponses: true\n  });\n\n  let response = yield options.xhr.send(req, collection.url, {\n    sandbox: options.sandbox\n  });\n\n  return response.props.supportedReportSet;\n});\n\nexport let isCollectionDirty = co.wrap(function *(collection, options) {\n  if (!collection.ctag) {\n    debug('Missing ctag.');\n    return false;\n  }\n\n  debug('Fetch remote getctag prop.');\n  var req = request.propfind({\n    props: [ { name: 'getctag', namespace: ns.CALENDAR_SERVER } ],\n    depth: 0\n  });\n\n  let responses = yield options.xhr.send(req, collection.account.homeUrl, {\n    sandbox: options.sandbox\n  });\n\n  let response = responses.filter(response => {\n    // Find the response that corresponds to the parameter collection.\n    return fuzzyUrlEquals(collection.url, response.href);\n  })[0];\n\n  if (!response) {\n    throw new Error('Could not find collection on remote. Was it deleted?');\n  }\n\n  debug('Check whether cached ctag matches remote.');\n  return collection.ctag !== response.props.getctag;\n});\n","/home/travis/build/npmtest/node-npmtest-dav/node_modules/dav/lib/xmlhttprequest.js":"let debug = require('./debug')('dav:xmlhttprequest');\n\nlet Native;\nif (typeof self !== 'undefined' && 'XMLHttpRequest' in self) {\n  Native = self.XMLHttpRequest;\n} else {\n  // Trick browserify into not loading XMLHttpRequest polyfill\n  // since it is available in the platform (including web workers)\n  Native = require(false || 'xmlhttprequest').XMLHttpRequest;\n}\n\n/**\n * @fileoverview Promise wrapper around native xhr api.\n */\nexport default class XMLHttpRequest {\n  constructor(options) {\n    this.request = new Native(options);\n    this.sandbox = null;\n\n    /* readwrite */\n    [\n      'response',\n      'responseText',\n      'responseType',\n      'responseXML',\n      'timeout',\n      'upload',\n      'withCredentials'\n    ].forEach(attribute => {\n      Object.defineProperty(this, attribute, {\n        get: function() { return this.request[attribute]; },\n        set: function(value) { this.request[attribute] = value; }\n      });\n    });\n\n    /* readonly */\n    [\n      'status',\n      'statusText'\n    ].forEach(attribute => {\n      Object.defineProperty(this, attribute, {\n        get: function() { return this.request[attribute]; }\n      });\n    });\n  }\n\n  abort() {\n    return this._callNative('abort', arguments);\n  }\n\n  getAllResponseHeaders() {\n    return this._callNative('getAllResponseHeaders', arguments);\n  }\n\n  getResponseHeader() {\n    return this._callNative('getResponseHeader', arguments);\n  }\n\n  open() {\n    return this._callNative('open', arguments);\n  }\n\n  overrideMimeType() {\n    return this._callNative('overrideMimeType', arguments);\n  }\n\n  setRequestHeader() {\n    return this._callNative('setRequestHeader', arguments);\n  }\n\n  send(data) {\n    debug(`Sending request data: ${data}`);\n    if (this.sandbox) this.sandbox.add(this);\n    let request = this.request;\n    request.send(data);\n    return new Promise(function(resolve, reject) {\n      request.onreadystatechange = function() {\n        if (request.readyState !== 4 /* done */) {\n          return;\n        }\n\n        if (request.status < 200 || request.status >= 400) {\n          return reject(new Error(`Bad status: ${request.status}`));\n        }\n\n        return resolve(request.responseText);\n      };\n\n      request.ontimeout = function() {\n        reject(new Error(`Request timed out after ${request.timeout} ms`));\n      };\n    });\n  }\n\n  _callNative(method, args) {\n    return this.request[method].apply(this.request, args);\n  }\n}\n"}